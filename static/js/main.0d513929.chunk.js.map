{"version":3,"sources":["lib/store.ts","classes/TileConfig.ts","config/tiles/icons/images/key.png","config/tiles/icons/images/chest1.png","config/tiles/icons/images/chest2.png","config/tiles/icons/images/chest3.png","config/tiles/icons/images/chest4.png","config/tiles/icons/images/coal.png","config/tiles/icons/images/coin.png","config/tiles/icons/images/dagger1.png","config/tiles/icons/images/pickaxe.png","config/tiles/icons/images/rock.png","config/tiles/icons/images/healthPotion1.png","config/tiles/icons/images/healthPotion2.png","config/tiles/icons/images/manaPotion1.png","config/tiles/icons/images/manaPotion2.png","config/tiles/icons/images/elixer1.png","config/tiles/icons/images/elixer2.png","lib/createTile.ts","config/tiles/icons/Icon.tsx","config/tiles/lib/iterateAdjacentTiles.ts","config/tiles/rarities.ts","config/tiles/set1/index.ts","config/tiles/lib/hasCategory.ts","lib/utils.ts","lib/static.ts","lib/saveGameData.ts","config/taxPeriods.ts","lib/game.ts","config/tiles/lib/removeTile.ts","config/tiles/chests/index.tsx","config/tiles/mining/index.tsx","config/tiles/categories.ts","config/tiles/lib/findAdjacent.ts","config/tiles/lib/replaceTile.ts","config/tiles/potions/index.ts","config/tiles/empty/index.tsx","config/tiles/index.ts","lib/newGame.ts","lib/loadGameData.ts","components/Tile.tsx","components/Inventory.tsx","lib/newRound.ts","views/RoundEnd.tsx","components/Board.tsx","components/TileDetails.tsx","components/PickNewTile.tsx","components/Upgrades.tsx","components/GameEvents.tsx","views/MainGame.tsx","App.tsx","index.tsx"],"names":["store","state","gameData","spinning","tilesToPick","selectedTile","_update","value","update","Math","random","window","TileConfig","properties","id","name","icon","rarity","categories","description","calculateValue","context","onRemove","createMeta","topStat","this","Object","assign","createTile","tileConfig","meta","console","error","Error","emptyTileConfig","uuid","config","effects","data","spinValue","totalSpins","totalAppearances","highlight","Icon","image","className","src","alt","onClick","iconCache","Map","getIcon","get","Chest1","chest1","tileConfigsMap","Small_Chest","Chest2","chest2","Medium_Chest","Chest3","chest3","Large_Chest","Chest4","chest4","Dark_Chest","Coal","coal","Coin","coin","Pickaxe","pickaxe","iterateAdjacentTiles","callback","adjecentIndexes","getAdjacentIndexes","getTiles","map","COMMON","UNCOMMON","RARE","LEGENDARY","maxRarity","tileConfigs","total","tile","Dagger","dagger1","hasCategory","category","includes","randomInt","min","max","floor","GAME_ID","saveGameData","localData","localStorage","JSON","parse","gameState","stringify","replaceTileConfigs","ownedTiles","deckTiles","gameTiles","saveDate","Date","tiles","taxPeriods","totalDays","taxAmount","findTile","find","addOwnedTile","log","push","addGameTile","newTile","emptyTileIndex","findIndex","splice","pickRandomTile","array","tilesAvailable","reduce","acc","length","setInitialGameTiles","i","fillEmptyTiles","gridWidth","gridHeight","spin","boardTiles","availableGameTiles","availableIndex","gameTile","index","indexOf","generateBoard","resetTiles","forEach","interval","setInterval","clearInterval","totalCoins","boardValue","count","availableTiles","pickedTiles","getTileChances","chances","rand","chanceTotal","chance","pickTiles","nextTaxPeriodDay","calculateBoardTileValue","isAdjacent","originIndex","checkIndex","width","height","tileIndexes","boardIndex","startIndex","indexes","taxPeriod","currentTaxPeriod","currentTaxPeriodDay","newTotalCoins","roundEnded","savedCoins","lastTotalCoins","addGameEvent","message","events","calculateDeckScore","score","removeTile","removeValue","gameTilesIndex","replaceTile","createChestConfig","baseValue","Key","key","activated","uses","broken","Rock","rock","findAdjacent","item","createElixer","foundTiles","Small_Elixer","createNextPotion","nextConfig","Small_Health_Potion","healthPotion1","Medium_Health_Potion","healthPotion2","Small_Mana_Potion","manaPotion1","Medium_Mana_Potion","manaPotion2","elixer1","Medium_Elixer","elixer2","Empty","empty","set1","mining","potions","chests","tileName","replaceAll","values","tilesById","tileInstances","addTile","getTileConfigByName","tileId","deckTileIds","addDeckTile","newGame","buildDeck","loadGameData","updateTileConfigs","Tile","showValue","join","Inventory","onClickTile","newRound","RoundEnd","deckScore","tileRarityCost","rarityValue","rarityCount","pow","getRemainingTiles","availableTilesByRarity","keys","allTilesByRarity","ownedRarityCounts","rarityName","cost","enabled","rarityTiles","buyTileRarity","style","background","toFixed","otherTile","Board","fontSize","gridTemplateColumns","gridTemplateRows","emptyTileInstance","repeat","split","_","deckIndex","TileDetails","PickNewTile","pickTile","set","upgrades","buy","isComplete","Upgrades","upgrade","GameEvents","event","Header","MainGame","buttons","packageJson","version","opacity","display","flexDirection","App","useState","useEffect","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"mvCAGaA,G,MAAQ,CACnBC,MAAO,CACLC,SAAW,KACXC,UAAU,EACVC,YAAa,GACbC,aAAe,MAEjBC,QAAS,SAACC,KACVC,OAAQ,WACNR,EAAMM,QAAQG,KAAKC,aAItBC,OAAeX,MAAQA,E,yBCRXY,EAcX,WAAYC,GAAyB,yBAbrCC,GAAa,GAauB,KAZpCC,KAAgB,GAYoB,KAXpCC,UAWoC,OAVpCC,OAAiB,EAUmB,KATpCC,WAAuB,GASa,KARpCC,iBAQoC,OAPpCC,eAAwD,SAACC,GACvD,OAAO,GAM2B,KAJpCC,cAIoC,OAHpCC,gBAGoC,OAFpCC,aAEoC,EAClCC,KAAKV,KAAO,GAGZW,OAAOC,OAAOF,KAAMZ,IC1BT,MAA0B,gCCA1B,MAA0B,mCCA1B,MAA0B,mCCA1B,MAA0B,mCCA1B,MAA0B,mCCA1B,MAA0B,iCCA1B,MAA0B,iCCA1B,MAA0B,oCCA1B,MAA0B,oCCA1B,MAA0B,iCCA1B,MAA0B,0CCA1B,MAA0B,0CCA1B,MAA0B,wCCA1B,MAA0B,wCCA1B,MAA0B,oCCA1B,MAA0B,oC,QCgBlC,SAASe,EAAWC,EAAyBC,GAAkB,IAAD,EAsBnE,OArBKD,IACHE,QAAQC,MACN,IAAIC,MACF,qEAGJJ,EAAaK,KAGVJ,GAAQD,EAAWN,aACtBO,EAAOD,EAAWN,cAGO,CACzBT,GAAIqB,cACJC,OAAQP,EACRQ,QAAS,GACTC,KA5ByB,CACzBC,UAAW,EACXC,WAAY,EACZC,iBAAkB,EAClBC,WAAW,GAyBXZ,KAAI,UAAEA,SAAF,QAAU,I,WCGX,SAASa,EAAT,GAAqD,IAArCC,EAAoC,EAApCA,MAAef,EAAqB,EAA7BO,OAC5B,OACE,qBACES,UAAU,OACVC,IAAKF,EACLG,IAAI,GACJC,QAAS,WACHnB,IACF7B,EAAMC,MAAMI,aAAeuB,EAAWC,GACtC7B,EAAMQ,aAShB,IAAMyC,EAAY,IAAIC,IAEtB,SAASC,EAAQP,EAAeR,GAC9B,IAAIpB,EAAOiC,EAAUG,IAAIhB,EAAOrB,MAMhC,OAJKC,IACHA,EAAO,cAAC2B,EAAD,CAAMC,MAAOA,EAAOR,OAAQA,KAG9BpB,EAGF,IAGMqC,EAAS,kBAAMF,EAAQG,EAAQC,GAAeC,cAC9CC,EAAS,kBAAMN,EAAQO,EAAQH,GAAeI,eAC9CC,EAAS,kBAAMT,EAAQU,EAAQN,GAAeO,cAC9CC,EAAS,kBAAMZ,EAAQa,EAAQT,GAAeU,aAE9CC,EAAO,kBAAMf,EAAQgB,EAAMZ,GAAeW,OAC1CE,EAAO,kBAAMjB,EAAQkB,EAAMd,GAAea,OAG1CE,EAAU,kBAAMnB,EAAQoB,EAAShB,GAAee,UC7EtD,SAASE,EACdnD,EACAoD,GAEA,IAAMC,EAAkBrD,EAAQsD,qBAIhC,OAFctD,EAAQuD,SAASF,GAElBG,IAAIJ,GCXZ,IAAMxD,EAAS,CACpB6D,OAAQ,EACRC,SAAU,EACVC,KAAM,EACNC,UAAW,GAGAC,EAAYjE,EAAOgE,UCsCjBE,EAtCK,CAClBjB,KAAM,IAAItD,EAAW,CACnBE,GAAI,uCACJE,KAAMkD,EACNjD,OAAQA,EAAO6D,OACf5D,WAAY,GACZE,eAAgB,SAACC,GACf,IAAI+D,EAAQ,EAQZ,OANAZ,EAAqBnD,GAAS,SAACgE,GACJ,SAArBA,EAAKjD,OAAOrB,OACdqE,GAAS,MAINA,KAGXE,OAAQ,IAAI1E,EAAW,CACrBE,GAAI,uCACJE,KHmDmB,kBAAMmC,EAAQoC,EAAShC,GAAe+B,SGlDzDrE,OAAQA,EAAO6D,OACf5D,WAAY,GACZE,eAAgB,SAACC,GACf,OAAO,KAGX+C,KAAM,IAAIxD,EAAW,CACnBE,GAAI,uCACJE,KAAMoD,EACNnD,OAAQA,EAAO6D,OACf5D,WAAY,GACZE,eAAgB,SAACC,GACf,OAAO,MCtCN,SAASmE,EAAYH,EAAoBI,GAC9C,OAAOJ,EAAKjD,OAAOlB,WAAWwE,SAASD,G,WCHlC,SAASE,EAAUC,EAAaC,GACrC,OAAOpF,KAAKqF,MAAMrF,KAAKC,UAAYmF,EAAMD,EAAM,IAAMA,ECDhD,IAAMG,EAAU,uCCGhB,SAASC,IACd,IAAIC,EAAYC,aAAa,GAAD,OAAIH,IAG9BE,EADEA,EACUE,KAAKC,MAAMH,GAEX,GAId,IAAMI,EAAYF,KAAKC,MAAMD,KAAKG,UAAUtG,EAAMC,MAAMC,WAExDqG,EAAmBF,EAAUG,YAC7BD,EAAmBF,EAAUI,WAC7BF,EAAmBF,EAAUK,WAE7BT,EAAUI,UAAYA,EACtBJ,EAAUU,SAAW,IAAIC,KAEzBV,aAAa,GAAD,OAAIH,IAAaI,KAAKG,UAAUL,GAG9C,SAASM,EAAmBM,GAAe,IAAD,gBACrBA,GADqB,IACxC,2BAA0B,CAAC,IAAhBxB,EAAe,QACxBA,EAAKjD,OAAS,CAAEtB,GAAIuE,EAAKjD,OAAOtB,KAFM,+BCzBnC,IAAMgG,EAAa,CACxB,CACEC,UAAW,EACXC,UAAW,GAEb,CACED,UAAW,EACXC,UAAW,IAEb,CACED,UAAW,EACXC,UAAW,IAEb,CACED,UAAW,EACXC,UAAW,KAEb,CACED,UAAW,EACXC,UAAW,KAEb,CACED,UAAW,EACXC,UAAW,KAEb,CACED,UAAW,GACXC,UAAW,MChBR,SAASC,EAASJ,EAAuB/F,GAC9C,OAAO+F,EAAMK,MAAK,SAAC7B,GACjB,OAAOA,EAAKjD,OAAOtB,KAAOA,KAIvB,SAASqG,IAAwD,IAA3CtF,EAA0C,uDAAjBK,GAC5CsE,EAAexG,EAAMC,MAAMC,SAA3BsG,WAER,GAAIS,EAAST,EAAY3E,EAAWf,IAClCiB,QAAQqF,IAAR,2BAAgCvF,EAAWd,WAD7C,CAKAgB,QAAQqF,IAAR,4BAAiCvF,EAAWd,OAE5C,IAAMsE,EAAOzD,EAAWC,GAExB2E,EAAWa,KAAKhC,IAcX,SAASiC,GAAYC,GAAwB,IAC1Cb,EAAc1G,EAAMC,MAAMC,SAA1BwG,UAEFc,EAAiBd,EAAUe,WAAU,SAACpC,GAC1C,OAAOA,EAAKjD,OAAOtB,KAAOoB,GAAgBpB,MAGxC0G,GAAkB,EACpBd,EAAUgB,OAAOF,EAAgB,EAAGD,GAEpCb,EAAUW,KAAKE,GAiBZ,SAASI,GAAed,EAAuB3B,GACpD,IALiC0C,EAK3BC,EAAiBhB,EAAMiB,QAAO,SAACC,EAAK1C,GAKxC,OAJIA,EAAKjD,OAAOnB,QAAUiE,GACxB6C,EAAIV,KAAKhC,GAGJ0C,IACN,IAEH,OAbiCH,EAaIC,GAZxBlC,EAAU,EAAGiC,EAAMI,OAAS,IAepC,SAASC,KAMd,IANqC,IAC7B/H,EAAaF,EAAMC,MAAnBC,SACAuG,EAAcvG,EAAduG,UAEFC,EAA4B,GAEzBwB,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,IAAM7C,EAAOsC,GAAelB,EAAWxF,EAAO6D,QAC9C4B,EAAUW,KAAKzF,EAAWyD,EAAKjD,SAGjClC,EAASwG,UAAYA,EAErByB,KAGK,SAASA,KAId,IAJgC,IACxBjI,EAAaF,EAAMC,MAAnBC,SACAwG,EAAqCxG,EAArCwG,UAAW0B,EAA0BlI,EAA1BkI,UAAWC,EAAenI,EAAfmI,WAErBH,EAAI,EAAGxB,EAAUsB,OAASI,EAAYC,EAAYH,IACzDxB,EAAUW,KAAKzF,EAAWM,KAoCvB,SAASoG,KAAQ,IACdpI,EAAaF,EAAMC,MAAnBC,SACAkI,EAAqClI,EAArCkI,UAAWC,EAA0BnI,EAA1BmI,WAAY5B,EAAcvG,EAAduG,UAE/BvG,EAASqI,WApCJ,WAML,IAN+B,IACvBrI,EAAaF,EAAMC,MAAnBC,SACAwG,EAAqCxG,EAArCwG,UAAW0B,EAA0BlI,EAA1BkI,UAAWC,EAAenI,EAAfmI,WACxBE,EAAa,GACbC,EAAkB,YAAO9B,GAEtBwB,EAAI,EAAGA,EAAIE,EAAYC,EAAYH,IAAK,CAE/C,IAAMO,EAAiBhI,KAAKqF,MAC1BrF,KAAKC,SAAW8H,EAAmBR,QAE/BU,EAAWF,EAAmBC,GAC9BE,EAAQjC,EAAUkC,QAAQF,GAGhCH,EAAWlB,KAAKsB,GAEhBH,EAAmBd,OAAOe,EAAgB,GAG5C,OAAOF,EAgBeM,GAbjB,WAGL,IAH4B,IAAD,EAC8B7I,EAAMC,MAAMC,SAA7DkI,EADmB,EACnBA,UAAWC,EADQ,EACRA,WAAY3B,EADJ,EACIA,UAAW6B,EADf,EACeA,WAEjCL,EAAI,EAAGA,EAAIE,EAAYC,EAAYH,IAC7BxB,EAAU6B,EAAWL,IAC7B5F,KAAKC,UAAY,EAUxBuG,GAqDsB9I,EAAMC,MAAMC,SAA1BwG,UAGEqC,SAAQ,SAAC1D,GACjBA,EAAK/C,KAAKE,gBAtDZxC,EAAMC,MAAME,UAAW,EACvBH,EAAMQ,SAEN,IAAImI,EAAQ,EACNK,EAAWC,aAAY,WAAO,IAC1BV,EAA0BrI,EAA1BqI,WAAY7B,EAAcxG,EAAdwG,UAEhBiC,EAAQ,GAAKA,GAASP,EAAYC,IACnB3B,EAAU6B,EAAWI,EAAQ,IACrCrG,KAAKI,WAAY,GAG5B,GAAIiG,EAAQP,EAAYC,EActB,OAXAa,cAAcF,GAEdhJ,EAAMC,MAAME,UAAW,EACvBH,EAAMC,MAAMC,SAASiJ,YAAcnJ,EAAMC,MAAMC,SAASkJ,WACxDpJ,EAAMC,MAAMG,YAwJlB,SAAmByG,GAIjB,IAJoD,IAAZwC,EAAW,uDAAH,EAC1CC,EAAc,YAAOzC,GACrB0C,EAAc,GAF+B,WAI1CrB,GAJ0C,MAKhBsB,GAAeF,GAAxCG,EALyC,EAKzCA,QAEFC,EAAO/D,EAAU,EAP0B,EAKhCgE,aAIXhB,EAAQc,EAAQhC,WAAU,SAACmC,GAC/B,OAAOA,GAAUF,KAGbrE,EAAOiE,EAAe5B,OAAOiB,EAAO,GAAG,GAEzCtD,GACFkE,EAAYlC,KAAKzF,EAAWyD,EAAKjD,UAZ5B8F,EAAI,EAAGA,EAAImB,EAAOnB,IAAM,EAAxBA,GAuBT,OAAOqB,EAnLuBM,CAAUpD,GACpCzG,EAAMQ,SAENsJ,UAEA9D,IAKF,GAAI2C,EAAQP,EAAYC,EAAY,CAClC,IAAMhD,EAAOqB,EAAU6B,EAAWI,IAClCtD,EAAK/C,KAAKI,WAAY,EACtB2C,EAAK/C,KAAKG,mBACV4C,EAAK/C,KAAKC,UAAYwH,GAAwB1E,EAAMsD,GAGtDA,IAEA,IAlCiC,EAkC7BS,EAAa,EAlCgB,cAoCHb,GApCG,IAoCjC,2BAA0C,CACxCa,GAAc1C,EAD0B,SACCpE,KAAKC,WArCf,8BAuCjCvC,EAAMC,MAAMC,SAASkJ,WAAaA,EAElCpJ,EAAMQ,WACL,KAYE,SAASwJ,GACdC,EACAC,EACAC,EACAC,GAGA,QAAIF,EAAa,GAAKA,GAAcC,EAAQC,MAKxCH,EAAc,IAAMC,GAAcD,EAAc,IAAMC,GACpDzJ,KAAKqF,MAAMoE,EAAaC,KAAW1J,KAAKqF,MAAMmE,EAAcE,OAOhEF,EAAcE,EAAQ,IAAMD,GAC5BD,EAAcE,EAAQ,IAAMD,GAG1BzJ,KAAKqF,MAAMoE,EAAaC,KACxB1J,KAAKqF,OAAOmE,EAAcE,GAASA,MAQrCF,EAAcE,EAAQ,IAAMD,GAC5BD,EAAcE,EAAQ,IAAMD,GAG1BzJ,KAAKqF,MAAMoE,EAAaC,KACxB1J,KAAKqF,OAAOmE,EAAcE,GAASA,MAmCzC,SAASvF,GAASyF,GAAwB,IAAD,EACLrK,EAAMC,MAAMC,SAAtCqI,EAD+B,EAC/BA,WAAY7B,EADmB,EACnBA,UAEpB,OAAO2D,EAAYxF,KAAI,SAAC8D,GACtB,OAAOjC,EAAU6B,EAAWI,OAIzB,SAASoB,GACd1E,EACAiF,GACC,IACOpK,EAAaF,EAAMC,MAAnBC,SACAkI,EAA0BlI,EAA1BkI,UAAWC,EAAenI,EAAfmI,WAEbhH,EAAU,CACdgE,OACAnF,WACAyE,mBAAoB,WAClB,OA7CC,SACL4F,EACAJ,EACAC,GAEA,IAAMI,EAAoB,GAE1BA,EAAQnD,KAAKkD,EAAaJ,GAC1BK,EAAQnD,KAAKkD,EAAaJ,GAC1BK,EAAQnD,KAAKkD,EAAa,GAC1BC,EAAQnD,KAAKkD,EAAa,GAE1BC,EAAQnD,KAAKkD,EAAaJ,EAAQ,GAClCK,EAAQnD,KAAKkD,EAAaJ,EAAQ,GAClCK,EAAQnD,KAAKkD,EAAaJ,EAAQ,GAClCK,EAAQnD,KAAKkD,EAAaJ,EAAQ,GAElC,IAAK,IAAIjC,EAAI,EAAGA,GAAK,EAAGA,IACjB8B,GAAWO,EAAYC,EAAQtC,GAAIiC,EAAOC,IAC7CI,EAAQ9C,OAAOQ,EAAG,GAItB,OAAOsC,EAsBI7F,CAAmB2F,EAAYlC,EAAWC,IAEnDzD,aAGF,OAAOS,EAAKjD,OAAOhB,eAAeC,GAGpC,SAASmI,GAAe3C,GACtB,IAD6C,EACvC4C,EAAoB,GACtBE,EAAc,EAF2B,cAI1B9C,GAJ0B,IAI7C,2BAA0B,CAAC,IAAhBxB,EAAe,QAExBsE,GAAezE,EAAY,EAAIG,EAAKjD,OAAOnB,OAC3CwI,EAAQpC,KAAKsC,IAP8B,8BAU7C,MAAO,CAAEF,UAASE,eAiCb,SAASG,KAAoB,IAC1B5J,EAAaF,EAAMC,MAAnBC,SACFuK,EAAY3D,EAAW5G,EAASwK,kBAItC,GAFAxK,EAASyK,sBAELzK,EAASyK,qBAAuBF,EAAU1D,UAAW,CACvD7G,EAASwK,mBACTxK,EAASyK,oBAAsB,EAE/B,IAAMC,EAAgB1K,EAASiJ,WAAasB,EAAUzD,UAElD4D,EAAgB,IAClB1K,EAAS2K,YAAa,EACtB3K,EAAS4K,YAAc5K,EAASiJ,WAChCjJ,EAAS6K,eAAiB7K,EAASiJ,YAGrCjJ,EAASiJ,WAAayB,EAGxB5K,EAAMQ,SAGD,SAASwK,GAAT,GAA8C,IAAD,IAArBC,eAAqB,MAAX,GAAW,EAC7BjL,EAAMC,MAAnBC,SAECgL,OAAO7D,KAAK,CACnBvG,GAAIqB,cACJ8I,YAGFlJ,QAAQqF,IAAR,sBAA2B6D,IAGtB,SAASE,KAAsB,IAAD,EAC3BjL,EAAaF,EAAMC,MAAnBC,SACJkL,EAAQ,EAFuB,cAIhBlL,EAASuG,WAJO,IAInC,2BAAuC,CACrC2E,GADqC,QACvBhJ,OAAOnB,QALY,8BAQnC,OAAOmK,EAAQlL,EAASuG,UAAUuB,OClY7B,SAASqD,GAAWhG,EAAoBhE,GAC7C,IAAIiK,EAEAjG,EAAKjD,OAAOd,WACdgK,EAAcjG,EAAKjD,OAAOd,SAASD,IAJmC,IAOhEqF,EAAcrF,EAAQnB,SAAtBwG,UACF6E,EAAiB7E,EAAUkC,QAAQvD,GAGrCmG,EAAc5J,EAAWM,IAE7B,GAAIoJ,EAAa,CAAC,IACVzE,EAAUyE,EAAVzE,MAGN,UAAIA,QAAJ,IAAIA,OAAJ,EAAIA,EAAOmB,OAAQ,CACjBwD,EAAc3E,EAAM,GAGpB,IAAK,IAAIqB,EAAI,EAAGA,EAAIrB,EAAMmB,OAAQE,IAChCZ,GAAYT,EAAMqB,IAKlBoD,EAAY/K,QACdiL,EAAYlJ,KAAKC,UAAY+I,EAAY/K,OAI7CmG,EAAU6E,GAAkBC,EC7B9B,SAASC,GAAT,GAA6D,IAAhCC,EAA+B,EAA/BA,UAAWJ,EAAoB,EAApBA,YACtC,MAAO,CACLpK,WAAY,CAAC,SACbH,KAAM,GACNI,YAAa,WACX,OACE,mEAC8BmK,EAD9B,IAC2C,cAAC,EAAD,QAI/ClK,eAAgB,SAACC,GACf,OAAOqK,GAETpK,SAAU,SAACD,GACT,MAAO,CAAEd,MAAO+K,KAKtB,IA4DenG,GA5DK,CAClBwG,IAAK,IAAI/K,EAAW,CAClBE,GAAI,uCACJC,KAAM,GACNI,YAAa,WACX,OACE,wDACkB,cAAC,EAAD,IADlB,IAC6B,cAAC,EAAD,IAD7B,IACwC,cAAC,EAAD,IADxC,IACmD,cAAC,EAAD,IADnD,uCAMJH,KX6Be,kBAAMmC,EAAQyI,EAAKrI,GAAeoI,MW5BjD1K,OAAQA,EAAO6D,OACf5D,WAAY,CAAC,OACbE,eAAgB,SAACC,GACf,IAAIwK,GAAY,EAehB,OAbArH,EAAqBnD,GAAS,SAACgE,GACzBG,EAAYH,EAAM,WAEpBgG,GAAWhG,EAAMhE,GACjBwK,GAAY,MAIZA,GAEFR,GAAWhK,EAAQgE,KAAMhE,GAGpB,KAGXmC,YAAa,IAAI5C,EAAJ,aACXE,GAAI,uCACJE,KAAMqC,EACNpC,OAAQA,EAAO6D,QACZ2G,GAAkB,CAAEC,UAAW,EAAGJ,YAAa,OAEpD3H,aAAc,IAAI/C,EAAJ,aACZE,GAAI,uCACJE,KAAMyC,EACNxC,OAAQA,EAAO8D,UACZ0G,GAAkB,CAAEC,UAAW,EAAGJ,YAAa,OAEpDxH,YAAa,IAAIlD,EAAJ,aACXE,GAAI,uCACJE,KAAM4C,EACN3C,OAAQA,EAAO+D,MACZyG,GAAkB,CAAEC,UAAW,EAAGJ,YAAa,OAEpDrH,WAAY,IAAIrD,EAAJ,aACVE,GAAI,uCACJE,KAAM+C,EACN9C,OAAQA,EAAOgE,WACZwG,GAAkB,CAAEC,UAAW,EAAGJ,YAAa,QCDvCnG,GAxEK,CAClBb,QAAS,IAAI1D,EAAW,CACtBE,GAAI,uCACJC,KAAM,GACNI,YAAa,WACX,OAAO,iEAETH,KAAMsD,EACNrD,OAAQA,EAAO6D,OACf5D,WAAY,CAAC,UACbK,WAAY,WACV,MAAO,CAAEuK,KAAM,IAEjBtK,QAAS,SAAC6D,GACR,OAAOA,EAAKvD,KAAKgK,MAEnB1K,eAAgB,SAACC,GACf,IAAI0K,GAAS,EAwBb,OAtBAvH,EAAqBnD,GAAS,SAACgE,GACzB0G,GAIAvG,EAAYH,EAAM,UACpBgG,GAAWhG,EAAMhE,GACjBU,QAAQqF,IAAI/F,EAAQgE,KAAKvD,MACzBT,EAAQgE,KAAKvD,KAAKgK,OAEa,IAA3BzK,EAAQgE,KAAKvD,KAAKgK,OACpBC,GAAS,EACTf,GAAa,CAAEC,QAAS,yBAK1Bc,GAEFV,GAAWhK,EAAQgE,KAAMhE,GAGpB,KAGX2K,KAAM,IAAIpL,EAAW,CACnBE,GAAI,uCACJC,KAAM,GACNI,YAAa,WACX,OACE,kDACY,cAAC,EAAD,IADZ,kBACsC,cAAC,EAAD,QAI1CH,KZegB,kBAAMmC,EAAQ8I,EAAM1I,GAAeyI,OYdnD/K,OAAQA,EAAO6D,OACf5D,WAAY,CAAC,QACbE,eAAgB,SAACC,GACf,OAAO,GAETC,SAAU,SAACD,GACT,IAAMkG,EAAU3F,EAAW2B,GAAeW,MAM1C,OAJA8G,GAAa,CACXC,QAAQ,2BAAD,OAA6B1D,EAAQnF,OAAOrB,QAG9C,CAAE8F,MAAO,CAACU,QC/EVrG,GAEU,sBAFVA,GAGW,uBAHXA,GAIQ,oBAJRA,GAKS,qBALTA,GAMG,eANHA,GAOI,gBCFV,SAASgL,GACd7K,EACAoE,GAEA,OAAOjB,EAAqBnD,GAAS,SAACgE,GACpC,GAAIG,EAAYH,EAAMI,GACpB,OAAOJ,KAERyC,QAAO,SAACC,EAAKoE,GAId,OAHIA,GACFpE,EAAIV,KAAK8E,GAEJpE,IACN,ICdE,SAASyD,GACdnG,EACAkC,EACAlG,GACC,IAAD,EACkCA,EAAQnB,SAAlCwG,EADR,EACQA,UAAW6B,EADnB,EACmBA,WACbgD,EAAiB7E,EAAUkC,QAAQvD,GACnCiF,EAAa/B,EAAWK,QAAQ2C,GAEtC7E,EAAU6E,GAAkBhE,EAE5BA,EAAQjF,KAAKC,UAAYwH,GAAwBxC,EAAS+C,GCc5D,SAAS8B,GAAa3G,EAAkBpE,GACtC,IAAMgL,EAAaH,GAAa7K,EAASoE,GAEzC,QAAI4G,EAAWrE,SACbqD,GAAWgB,EAAW,GAAIhL,GAC1BmK,GAAYnK,EAAQgE,KAAMzD,EAAWuD,GAAYmH,cAAejL,IACzD,GAMX,SAASkL,GACP9G,EACA+G,EACAnL,GAEA,IAAMgL,EAAaH,GAAa7K,EAASoE,GAEzC,OAAI4G,EAAWrE,QAAU,IACvBqD,GAAWgB,EAAW,GAAIhL,GAC1BgK,GAAWgB,EAAW,GAAIhL,GAC1BmK,GAAYnK,EAAQgE,KAAMzD,EAAW4K,GAAanL,IAC3C,GAMX,IAAM8D,GAAc,CAClBsH,oBAAqB,IAAI7L,EAAW,CAClCE,GAAI,uCACJE,KhBsByB,kBAC3BmC,EAAQuJ,EAAenJ,GAAekJ,sBgBtBpCxL,OAAQA,EAAO6D,OACf5D,WAAY,CAACA,IACbE,eAAgB,SAACC,GACf,OAAI+K,GAAalL,GAA8BG,IAK7CkL,GACErL,GACAiE,GAAYwH,qBACZtL,GAPK,EAaF,KAGXsL,qBAAsB,IAAI/L,EAAW,CACnCE,GAAI,uCACJE,KhBCyB,kBAC3BmC,EAAQyJ,EAAerJ,GAAeoJ,uBgBDpC1L,OAAQA,EAAO8D,SACf7D,WAAY,CAACA,IACbE,eAAgB,SAACC,GACf,OAAO,KAGXwL,kBAAmB,IAAIjM,EAAW,CAChCE,GAAI,uCACJE,KhBLuB,kBACzBmC,EAAQ2J,EAAavJ,GAAesJ,oBgBKlC5L,OAAQA,EAAO6D,OACf5D,WAAY,CAACA,IACbE,eAAgB,SAACC,GACf,OAAI+K,GAAalL,GAAgCG,IAK/CkL,GACErL,GACAiE,GAAY4H,mBACZ1L,GAPK,EAaF,KAGX0L,mBAAoB,IAAInM,EAAW,CACjCE,GAAI,uCACJE,KhB1BuB,kBACzBmC,EAAQ6J,EAAazJ,GAAewJ,qBgB0BlC9L,OAAQA,EAAO8D,SACf7D,WAAY,CAACA,IACbE,eAAgB,SAACC,GACf,OAAO,KAGXiL,aAAc,IAAI1L,EAAW,CAC3BE,GAAI,uCACJE,KhBhCmB,kBAAMmC,EAAQ8J,EAAS1J,GAAe+I,egBiCzDrL,OAAQA,EAAO+D,KACf9D,WAAY,CAACA,IACbE,eAAgB,SAACC,GACf,OACEkL,GACErL,GACAiE,GAAY+H,cACZ7L,GAGK,EAGF,KAGX6L,cAAe,IAAItM,EAAW,CAC5BE,GAAI,uCACJE,KhBlDmB,kBAAMmC,EAAQgK,EAAS5J,GAAe2J,gBgBmDzDjM,OAAQA,EAAO+D,KACf9D,WAAY,CAACA,IACbE,eAAgB,SAACC,GACf,OAAO,OAKE8D,MCvIAA,GAbK,CAClBiI,MAAO,IAAIxM,EAAW,CACpBE,GAAI,uCACJC,KAAM,GACNC,KjB2DiB,kBAAMmC,EArCzB,iFAqCwCI,GAAe6J,QiB1DrDnM,OAAQA,EAAO6D,OACf5D,WAAY,CAAC,SACbE,eAAgB,SAACC,GACf,OAAOA,EAAQgE,KAAK/C,KAAKC,WAAa,MCF/BL,GAAkBmL,GAAMD,MAExB7J,GAAc,+DACtB8J,IACAC,GACAC,IACAC,IACAC,IAML,IAAK,IAAMC,MAAYnK,GAAgB,CACjBA,GAAuBmK,IAChC3M,KAAO2M,GAASC,WAAW,IAAK,KAG7C,IAAMxI,GAAyB,YAAOzD,OAAOkM,OAAOrK,KAErC4B,MACF0I,GAAY,IAAI3K,IAChB4K,GAAgC,GCtB7C,SAASC,GAAQhN,GACf,IAAMc,ED6BD,SAA6Bd,GAClC,IAAMc,EAAa0B,GAAexC,GAMlC,OAJKc,GACHE,QAAQC,MAAM,IAAIC,MAAJ,qBAAwBlB,EAAxB,iBAGTc,ECpCYmM,CAAoBjN,GACvCoG,EAAatF,GVmBR,SAAqBoM,GAC1B,GAAKA,EAAL,CAD2C,IAKnCC,EAAgBlO,EAAMC,MAAMC,SAA5BgO,YAEHA,EAAYxI,SAASuI,IACxBC,EAAY7G,KAAK4G,IU1BnBE,CAAW,OAACtM,QAAD,IAACA,OAAD,EAACA,EAAYf,IAGnB,SAASsN,KAmBdpO,EAAMC,MAAMC,SAlBe,CACzBqI,WAAY,GACZ/B,WAAY,GACZ0H,YAAa,GACbzH,UAAW,GACXC,UAAW,GACX0B,UAAW,EACXC,WAAY,EACZe,WAAY,EACZD,WAAY,EACZ2B,WAAY,EACZC,eAAgB,EAChBL,iBAAkB,EAClBC,oBAAqB,EACrBE,YAAY,EACZK,OAAQ,IAIVlL,EAAMC,MAAMG,YAAc,GAE1B2N,GAAQ,QACRA,GAAQ,UACRA,GAAQ,WACRA,GAAQ,QVeH,WAAsB,IACnB7N,EAAaF,EAAMC,MAAnBC,SACAgO,EAA4BhO,EAA5BgO,YAAa1H,EAAetG,EAAfsG,WAErBtG,EAASuG,UAAYyH,EAAYrJ,KAAI,SAAC/D,GACpC,OAAOmG,EAAST,EAAY1F,IAAOc,EAAWM,OUfhDmM,GACApG,KACA6B,KC3CK,SAASwE,KAAgB,IAAD,EACzBrI,EAAYC,aAAa,GAAD,OAAIH,IAQhC,aALEE,EADEA,EACUE,KAAKC,MAAMH,GAEX,UAGd,aAAI,EAAWI,UAAW,CAExB,IAAMA,EAAsBJ,EAAUI,UAEtCkI,GAAkBlI,EAAUG,YAC5B+H,GAAkBlI,EAAUI,WAC5B8H,GAAkBlI,EAAUK,WAE5B1G,EAAMC,MAAMC,SAAW+F,EAAUI,WAIrC,SAASkI,GAAkB1H,GAAwB,IAAD,gBAC7BA,GAD6B,yBACrCxB,EADqC,QAE9CA,EAAKjD,OACH+C,GAAY+B,MAAK,SAACrF,GAChB,OAAOA,EAAWf,KAAOuE,EAAKjD,OAAOtB,OACjCoB,IAJV,2BAA2B,IADqB,+BClB3C,SAASsM,GAAT,GAAoD,IAApCnJ,EAAmC,EAAnCA,KAAMoJ,EAA6B,EAA7BA,UAAWzL,EAAkB,EAAlBA,QAChCH,EAAY,CAAC,QAenB,OAbIwC,EAAK/C,KAAKI,WACZG,EAAUwE,KAAK,aAaf,sBAAKxE,UAAWA,EAAU6L,KAAK,KAAM1L,QAVvC,WACEhD,EAAMC,MAAMI,aAAegF,EAC3BrF,EAAMQ,SAEFwC,GACFA,EAAQqC,IAKV,YACKA,EAAKjD,OAAOZ,SAAWiN,GACxB,qBAAK5L,UAAU,WAAf,SAA2BwC,EAAKjD,OAAOZ,QAAQ6D,OAE9CA,EAAK/C,KAAKC,WAAakM,GACxB,qBAAK5L,UAAU,QAAf,SAAwBwC,EAAK/C,KAAKC,YAEpC,cAAC8C,EAAKjD,OAAOpB,KAAb,OCzBC,SAAS2N,GAAT,GAAmD,IAA9B9H,EAA6B,EAA7BA,MAAO+H,EAAsB,EAAtBA,YACjC,OACE,qBAAK/L,UAAU,YAAf,SACGgE,EAAMhC,KAAI,SAACQ,GAAD,OACT,cAACmJ,GAAD,CAAoBnJ,KAAMA,EAAMrC,QAAS4L,GAA9BvJ,EAAKvE,SCTjB,SAAS+N,KAAY,IAClB3O,EAAaF,EAAMC,MAAnBC,SAERA,EAASwK,iBAAmB,EAC5BxK,EAASyK,oBAAsB,EAC/BzK,EAAS2K,YAAa,EACtB3K,EAASqI,WAAa,GACtBrI,EAASiJ,WAAa,EACtBjJ,EAASgL,OAAS,GAElBjD,KACA6B,KAEA9J,EAAMC,MAAMG,YAAc,GAE1BJ,EAAMQ,SCRD,SAASsO,KACd,IAAMC,EAAY5D,KAEVjL,EAAaF,EAAMC,MAAnBC,SAER,SAAS8O,EAAeC,EAAqBC,GAC3C,OAAsC,IAA/BzO,KAAK0O,IAAIF,EAAc,EAAG,IAAYC,EAAc,GAG7D,SAASE,IACP,IAAMC,EAA2C3N,OAAO4N,KACtDrO,GACA4D,KAAI,iBAAM,MACN0K,EAAqC7N,OAAO4N,KAChDrO,GACA4D,KAAI,iBAAM,MACN2K,EAA8B9N,OAAO4N,KAAKrO,GAAQ4D,KAAI,kBAAM,KAiBlE,OAfAiJ,GAAc/E,SAAQ,SAAC1D,GACrBkK,EAAiBlK,EAAKjD,OAAOnB,QAAQoG,KAAKhC,GAEtCA,EAAKjD,SAAWF,KAKf+E,EAAS/G,EAASsG,WAAYnB,EAAKjD,OAAOtB,IAG7C0O,EAAkBnK,EAAKjD,OAAOnB,UAF9BoO,EAAuBhK,EAAKjD,OAAOnB,QAAQoG,KAAKhC,OAM7C,CACLgK,yBACAE,mBACAC,qBApCqB,MA0DrBJ,IAHFC,EAvDuB,EAuDvBA,uBACAE,EAxDuB,EAwDvBA,iBACAC,EAzDuB,EAyDvBA,kBAGF,OACE,gCACE,mDACA,+CACgBtP,EAAS4K,WADzB,KACuC5K,EAAS6K,eADhD,yBAIA,gCACE,uJAIA,qBAAKlI,UAAU,eAAf,SACGnB,OAAO4N,KAAKrO,GAAQ4D,KAAI,SAAC4K,EAAY9G,GACpC,IAAMsG,EAAehO,EAAewO,GAE9BC,EAAOV,EAAeC,EADRO,EAAkB7G,IAEhCW,EAAiB+F,EAAuB1G,GAAOX,OAC/CnF,EAAY,CAAC,UACf8M,GAAU,EAOd,OALID,EAAOxP,EAAS4K,YAAiC,IAAnBxB,KAChCzG,EAAUwE,KAAK,YACfsI,GAAU,GAIV,sBAAuB9M,UAAWA,EAAU6L,KAAK,KAAjD,UACE,qBAAK7L,UAAU,OAAf,SAAuB4M,IACvB,qBAAK5M,UAAU,OAAf,SAAuB6M,IACvB,sBAAK7M,UAAU,kBAAf,UACGwM,EAAuB1G,GAAOX,OADjC,MAC4C,IACzCuH,EAAiB5G,GAAOX,OAF3B,sBAIC2H,GACC,wBAAQ3M,QAAS,kBAvDjC,SAAuB/B,GAAiB,IAAD,EACiBmO,IAA9CC,EAD6B,EAC7BA,uBAAwBG,EADK,EACLA,kBAE1BI,EAAcP,EAAuBpO,GAErC0H,EAAQhD,EAAU,EAAGiK,EAAY5H,OAAS,GAEhD9H,EAAS4K,YAAckE,EAAe/N,EAAQuO,EAAkBvO,IAEhEkG,EAAayI,EAAYjH,GAAOvG,QAEhCpC,EAAMQ,SA4C+BqP,CAAclH,IAArC,mBARMsG,WAelB,gCACE,yEACA,gCACE,sCACA,sBAAKa,MAAO,CAAEC,WAAYhB,EAAY,EAAI,MAAQ,QAAlD,yBACeA,EAAUiB,QAAQ,MAEjC,cAACrB,GAAD,CACE9H,MAAO3G,EAASuG,UAChBmI,YAAa,SAACvJ,GACZ,IAAMsD,EAAQzI,EAASuG,UAAUmC,QAAQvD,GAErCsD,GAAS,GACXzI,EAASuG,UAAUiB,OAAOiB,EAAO,YAM3C,8BACE,gCACE,iDACA,cAACgG,GAAD,CACE9H,MAAO3G,EAASsG,WAChBoI,YAAa,SAACvJ,GACInF,EAASuG,UAAUS,MAAK,SAAC+I,GACvC,OAAOA,EAAU7N,OAAOtB,KAAOuE,EAAKjD,OAAOtB,OAI3CZ,EAASuG,UAAUY,KAAKhC,WAMlC,gCACE,2CACA,cAACsJ,GAAD,CACE9H,MAAOiH,GACPc,YAAa,SAACvJ,GACInF,EAASsG,WAAWU,MAAK,SAAC+I,GACxC,OAAOA,EAAU7N,OAAOtB,KAAOuE,EAAKjD,OAAOtB,OAI3CZ,EAASsG,WAAWa,KAAKzF,EAAWyD,EAAKjD,eAMjD,wBAAQY,QAAS6L,GAAjB,2BCxJC,SAASqB,GAAT,GAAiE,IAAhD3H,EAA+C,EAA/CA,WAAY7B,EAAmC,EAAnCA,UAAWyD,EAAwB,EAAxBA,MAAOC,EAAiB,EAAjBA,OAC9C0F,EAAQ,CACZK,SAAU,QACVC,oBAAoB,UAAD,OAAYjG,EAAZ,UACnBkG,iBAAiB,UAAD,OAAYjG,EAAZ,WAGlB,GAA0B,IAAtB7B,EAAWP,OAAc,CAC3B,IAAMsI,EAAoB1O,EAAWM,IAErC,OACE,qBAAKW,UAAU,QAAQiN,MAAOA,EAA9B,SACG,IACES,OAAOpG,EAAQC,GACfoG,MAAM,IACN3L,KAAI,SAAC4L,EAAG9H,GACP,OAAO,cAAC6F,GAAD,CAAkBnJ,KAAMiL,GAAb3H,QAM5B,OACE,qBAAK9F,UAAU,QAAQiN,MAAOA,EAA9B,SACGvH,EAAW1D,KAAI,SAAC6L,EAAW/H,GAC1B,IAAMtD,EAAOqB,EAAUgK,GACvB,OAAO,cAAClC,GAAD,CAAoBnJ,KAAMA,EAAMoJ,WAAS,EAACzL,QAAS,cAAxCqC,EAAKvE,SC/BxB,SAAS6P,GAAT,GAAgD,IAAzBtL,EAAwB,EAAxBA,KAAMrC,EAAkB,EAAlBA,QAClC,IAAKqC,EACH,OAAO,KAF2C,IAK5CjD,EAAWiD,EAAXjD,OAER,OACE,sBAAKS,UAAU,eAAeG,QAASA,EAAvC,UACE,qBAAKH,UAAU,OAAf,SAAuBT,EAAOrB,OAC9B,cAACsE,EAAKjD,OAAOpB,KAAb,IACA,qBAAK6B,UAAU,cAAf,SACGT,EAAOjB,aAAeiB,EAAOjB,mBCd/B,SAASyP,KAAe,IACrBxQ,EAAgBJ,EAAMC,MAAtBG,YAER,SAASyQ,EAASxL,GACZA,GACFiC,GAAYjC,GAGdrF,EAAMC,MAAMG,YAAc,GAC1BJ,EAAMC,MAAMC,SAASqI,WAAa,GAClCvI,EAAMQ,SAGR,OACE,sBAAKqC,UAAU,cAAf,UACGzC,EAAYyE,KAAI,SAACQ,GAAD,OACf,cAACsL,GAAD,CAEEtL,KAAMA,EACNrC,QAAS,WACP6N,EAASxL,KAHNA,EAAKvE,OAOd,wBAAQkC,QAAS,kBAAM6N,KAAvB,qBTON1L,GAAY4D,SAAQ,SAAC3G,GACnByL,GAAUiD,IAAI1O,EAAOtB,GAAIsB,GACzB0L,GAAczG,KAAKzF,EAAWQ,OUnChC,IAAM2O,GAAW,CACf,CACEjQ,GAAI,uCACJC,KAAM,cACN2O,KAAM,WACJ,OAAO,GAETsB,IAAK,WACkBhR,EAAMC,MAAnBC,SACCkI,WAAa,EACtBD,KACAnI,EAAMQ,UAERyQ,WAAY,WACV,OAAO,IAGX,CACEnQ,GAAI,uCACJC,KAAM,eACN2O,KAAM,WACJ,OAAO,GAETsB,IAAK,WACkBhR,EAAMC,MAAnBC,SACCmI,YAAc,EACvBF,KACAnI,EAAMQ,UAERyQ,WAAY,WACV,OAAO,IAGX,CACEnQ,GAAI,uCACJC,KAAM,MACN2O,KAAM,WACJ,OAAO,GAETsB,IAAK,aACLC,WAAY,WACV,OAAO,KAKN,SAASC,KACd,OACE,qBAAKrO,UAAU,WAAf,SACGkO,GAASlM,KAAI,SAACsM,GACb,OACE,gCACE,8BAAMA,EAAQpQ,OACd,8BACE,wBAAQiC,QAASmO,EAAQH,IAAzB,qBAHMG,EAAQrQ,SChDrB,SAASsQ,GAAT,GAAwC,IAAlBlG,EAAiB,EAAjBA,OAC3B,OACE,qBAAKrI,UAAU,cAAf,SACGqI,EAAOrG,KAAI,SAACwM,GAAD,OACV,qBAAoBxO,UAAU,QAA9B,SACE,qBAAKA,UAAU,UAAf,SAA0BwO,EAAMpG,WADxBoG,EAAMvQ,S,aCSxB,SAASwQ,KAAU,IACTpR,EAAaF,EAAMC,MAAnBC,SACFuK,EAAY3D,EAAW5G,EAASwK,kBAEtC,OACE,qCACE,sBAAKoF,MAAO,CAAEK,SAAU,OAAxB,UACGjQ,EAASiJ,WACV,sBAAMtG,UAAU,UAAhB,SACE,cAAC,EAAD,MACM,IAJV,KAKK4H,EAAUzD,UACb,sBAAMnE,UAAU,UAAhB,SACE,cAAC,EAAD,MACM,IARV,gBASgB4H,EAAU1D,UAAY7G,EAASyK,oBAT/C,WAWA,gDAAmBzK,EAAS4K,iBAK3B,SAASyG,KAAY,IAAD,EACSvR,EAAMC,MAAhCC,EADiB,EACjBA,SAAUE,EADO,EACPA,YAEdoR,EAAU,KACTxR,EAAMC,MAAME,UAAaC,EAAY4H,SACxCwJ,EACE,mCACE,wBAAQxO,QAASsF,GAAjB,qBAKN,IAAMyG,EAAY5D,KAElB,OACE,sBAAKtI,UAAU,MAAf,UACE,4CAAe4O,GAAYC,WAC3B,cAACJ,GAAD,MACGlR,EAAY4H,QACb,gCACE,+CACA,cAAC4I,GAAD,OAGJ,sBAAKd,MAAO,CAAE6B,QAASvR,EAAY4H,OAAS,GAAM,GAAlD,UACE,sBAAK8H,MAAO,CAAE8B,QAAS,OAAQC,cAAe,OAA9C,UACE,gCACE,uCACA,cAAC3B,GAAD,CACE3H,WAAYrI,EAASqI,WACrB7B,UAAWxG,EAASwG,UACpByD,MAAOjK,EAASkI,UAChBgC,OAAQlK,EAASmI,aAElBmJ,EACD,sBAAK1B,MAAO,CAAEK,SAAU,OAAxB,yBACe,IACb,8BAAOjQ,EAASkJ,YAAclJ,EAASkJ,YAAe,UAG1D,qBAAK0G,MAAO,CAAE3F,MAAO,SACrB,gCACE,+CACA,cAACwG,GAAD,CAAatL,KAAMrF,EAAMC,MAAMI,kBAEjC,qBAAKyP,MAAO,CAAE3F,MAAO,SACrB,gCACE,wCACA,cAACiH,GAAD,CAAYlG,OAAQhL,EAASgL,eAGjC,gCACE,4CACA,cAACyD,GAAD,CAAW9H,MAAO3G,EAASwG,eAE7B,gCACE,sCACA,sBAAKoJ,MAAO,CAAEC,WAAYhB,EAAY,EAAI,MAAQ,QAAlD,yBACeA,EAAUiB,QAAQ,MAEjC,cAACrB,GAAD,CAAW9H,MAAO3G,EAASuG,eAE7B,gCACE,iDACA,cAACkI,GAAD,CAAW9H,MAAO3G,EAASsG,gBAE7B,gCACE,2CACA,cAACmI,GAAD,CACE9H,MAAOiH,GACPc,YAAa,SAACvJ,GACInF,EAASsG,WAAWU,MAAK,SAAC+I,GACxC,OAAOA,EAAU7N,OAAOtB,KAAOuE,EAAKjD,OAAOtB,OAI3CZ,EAASsG,WAAWa,KAAKzF,EAAWyD,EAAKjD,eAKjD,gCACE,0CACA,cAAC8O,GAAD,OAEF,wBACElO,QAAS,WACPoL,KACApO,EAAMQ,UAHV,iCAQA,wBACEwC,QAAS,WACPgD,KAFJ,+BAQF,8BACE,wBACEhD,QAAS,WACP9C,EAAS2K,YAAa,EACtB7K,EAAMQ,UAHV,4BA9HR8N,KCXAA,KAuBewD,OArBf,WACE,IAAMtR,EAASuR,mBAAS,GAAG,GAa3B,OAVAC,qBAAU,WACRhS,EAAMM,QAAUE,IACf,CAACA,IAECR,EAAMC,MAAMC,UACfkO,KAGmBpO,EAAMC,MAAnBC,SAEK2K,WACJ,cAACiE,GAAD,IAGF,cAACyC,GAAD,KCrBTU,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,GAAD,MAEFC,SAASC,eAAe,W","file":"static/js/main.0d513929.chunk.js","sourcesContent":["import { GameData } from \"../types/GameData\";\nimport { TileInstance } from \"../types/TileInstance\";\n\nexport const store = {\n  state: {\n    gameData: (null as unknown) as GameData,\n    spinning: false,\n    tilesToPick: [] as TileInstance[],\n    selectedTile: (null as unknown) as TileInstance | undefined,\n  },\n  _update: (value: number) => {}, // The function that triggers an update\n  update: (): void => {\n    store._update(Math.random());\n  },\n};\n\n(window as any).store = store;\n","import { TileInstance, TileMeta } from \"../types/TileInstance\";\nimport { TileValueContext } from \"../types/TileValueContext\";\n\nexport type RemoveValue = {\n  value?: number;\n  tiles?: TileInstance[];\n};\n\nexport class TileConfig {\n  id: string = \"\";\n  name?: string = \"\";\n  icon: any;\n  rarity: number = 0;\n  categories: string[] = [];\n  description?: () => any;\n  calculateValue: (context: TileValueContext) => number = (context) => {\n    return 0;\n  };\n  onRemove?: (context: TileValueContext) => RemoveValue | void;\n  createMeta?: () => TileMeta;\n  topStat?: (tile: TileInstance) => number;\n\n  constructor(properties: TileConfig) {\n    this.name = \"\";\n\n    // This is just easy\n    Object.assign(this, properties);\n  }\n}\n\nexport type TileConfigMap = {\n  [key: string]: TileConfig;\n};\n","export default __webpack_public_path__ + \"static/media/key.0629d73b.png\";","export default __webpack_public_path__ + \"static/media/chest1.b4054229.png\";","export default __webpack_public_path__ + \"static/media/chest2.d4ed67d0.png\";","export default __webpack_public_path__ + \"static/media/chest3.888bf5be.png\";","export default __webpack_public_path__ + \"static/media/chest4.28dffa1b.png\";","export default __webpack_public_path__ + \"static/media/coal.d3a30adc.png\";","export default __webpack_public_path__ + \"static/media/coin.3480412c.png\";","export default __webpack_public_path__ + \"static/media/dagger1.6892c2d5.png\";","export default __webpack_public_path__ + \"static/media/pickaxe.9f91b8f2.png\";","export default __webpack_public_path__ + \"static/media/rock.14a2b8aa.png\";","export default __webpack_public_path__ + \"static/media/healthPotion1.2cc42067.png\";","export default __webpack_public_path__ + \"static/media/healthPotion2.8e645ab4.png\";","export default __webpack_public_path__ + \"static/media/manaPotion1.03ef4a80.png\";","export default __webpack_public_path__ + \"static/media/manaPotion2.f6d761fd.png\";","export default __webpack_public_path__ + \"static/media/elixer1.126eb52b.png\";","export default __webpack_public_path__ + \"static/media/elixer2.f677e6cf.png\";","import { TileConfig } from \"../classes/TileConfig\";\nimport { TileData, TileInstance, TileMeta } from \"../types/TileInstance\";\nimport { v4 as uuid } from \"uuid\";\nimport { emptyTileConfig } from \"../config/tiles\";\n\nexport function createTileData() {\n  const tileData: TileData = {\n    spinValue: 0,\n    totalSpins: 0,\n    totalAppearances: 0,\n    highlight: false,\n  };\n\n  return tileData;\n}\n\nexport function createTile(tileConfig?: TileConfig, meta?: TileMeta) {\n  if (!tileConfig) {\n    console.error(\n      new Error(\n        \"Undefined tile config for creating a tile. Adding an empty tile.\"\n      )\n    );\n    tileConfig = emptyTileConfig;\n  }\n\n  if (!meta && tileConfig.createMeta) {\n    meta = tileConfig.createMeta();\n  }\n\n  const tile: TileInstance = {\n    id: uuid(),\n    config: tileConfig,\n    effects: {},\n    data: createTileData(),\n    meta: meta ?? {},\n  };\n\n  return tile;\n}\n","import key from \"./images/key.png\";\nimport chest1 from \"./images/chest1.png\";\nimport chest2 from \"./images/chest2.png\";\nimport chest3 from \"./images/chest3.png\";\nimport chest4 from \"./images/chest4.png\";\n\nimport coal from \"./images/coal.png\";\nimport coin from \"./images/coin.png\";\nimport dagger1 from \"./images/dagger1.png\";\n\nimport pickaxe from \"./images/pickaxe.png\";\nimport rock from \"./images/rock.png\";\n\nimport healthPotion1 from \"./images/healthPotion1.png\";\nimport healthPotion2 from \"./images/healthPotion2.png\";\nimport healthPotion3 from \"./images/healthPotion3.png\";\n\nimport manaPotion1 from \"./images/manaPotion1.png\";\nimport manaPotion2 from \"./images/manaPotion2.png\";\nimport manaPotion3 from \"./images/manaPotion3.png\";\n\nimport elixer1 from \"./images/elixer1.png\";\nimport elixer2 from \"./images/elixer2.png\";\nimport elixer3 from \"./images/elixer3.png\";\n\nimport { store } from \"../../../lib/store\";\nimport { createTile } from \"../../../lib/createTile\";\nimport { tileConfigsMap } from \"..\";\nimport { TileConfig } from \"../../../classes/TileConfig\";\n\nconst empty =\n  \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\n\ninterface Props {\n  image?: any;\n  config?: TileConfig;\n}\n\nexport function Icon({ image, config: tileConfig }: Props) {\n  return (\n    <img\n      className=\"icon\"\n      src={image}\n      alt=\"\"\n      onClick={() => {\n        if (tileConfig) {\n          store.state.selectedTile = createTile(tileConfig);\n          store.update();\n        }\n      }}\n    />\n  );\n}\n\n// Cache icon instances for faster reference\n// There is no need to create one for each new instance\nconst iconCache = new Map<string, JSX.Element>();\n\nfunction getIcon(image: string, config: TileConfig) {\n  let icon = iconCache.get(config.name!);\n\n  if (!icon) {\n    icon = <Icon image={image} config={config} />;\n  }\n\n  return icon;\n}\n\nexport const Empty = () => getIcon(empty, tileConfigsMap.Empty);\n\nexport const Key = () => getIcon(key, tileConfigsMap.Key);\nexport const Chest1 = () => getIcon(chest1, tileConfigsMap.Small_Chest);\nexport const Chest2 = () => getIcon(chest2, tileConfigsMap.Medium_Chest);\nexport const Chest3 = () => getIcon(chest3, tileConfigsMap.Large_Chest);\nexport const Chest4 = () => getIcon(chest4, tileConfigsMap.Dark_Chest);\n\nexport const Coal = () => getIcon(coal, tileConfigsMap.Coal);\nexport const Coin = () => getIcon(coin, tileConfigsMap.Coin);\nexport const Dagger1 = () => getIcon(dagger1, tileConfigsMap.Dagger);\n\nexport const Pickaxe = () => getIcon(pickaxe, tileConfigsMap.Pickaxe);\nexport const Rock = () => getIcon(rock, tileConfigsMap.Rock);\n\nexport const HealthPotion1 = () =>\n  getIcon(healthPotion1, tileConfigsMap.Small_Health_Potion);\nexport const HealthPotion2 = () =>\n  getIcon(healthPotion2, tileConfigsMap.Medium_Health_Potion);\n\nexport const ManaPotion1 = () =>\n  getIcon(manaPotion1, tileConfigsMap.Small_Mana_Potion);\nexport const ManaPotion2 = () =>\n  getIcon(manaPotion2, tileConfigsMap.Medium_Mana_Potion);\n\nexport const Elixer1 = () => getIcon(elixer1, tileConfigsMap.Small_Elixer);\nexport const Elixer2 = () => getIcon(elixer2, tileConfigsMap.Medium_Elixer);\n","import { TileInstance } from \"../../../types/TileInstance\";\nimport { TileValueContext } from \"../../../types/TileValueContext\";\n\nexport function iterateAdjacentTiles(\n  context: TileValueContext,\n  callback: any\n): TileInstance[] {\n  const adjecentIndexes = context.getAdjacentIndexes();\n\n  const tiles = context.getTiles(adjecentIndexes);\n\n  return tiles.map(callback);\n}\n","export const rarity = {\n  COMMON: 0,\n  UNCOMMON: 1,\n  RARE: 2,\n  LEGENDARY: 3,\n};\n\nexport const maxRarity = rarity.LEGENDARY;\n","import { TileConfig } from \"../../../classes/TileConfig\";\nimport { TileInstance } from \"../../../types/TileInstance\";\nimport { TileValueContext } from \"../../../types/TileValueContext\";\nimport { Coal, Coin, Dagger1 } from \"../icons/Icon\";\nimport { iterateAdjacentTiles } from \"../lib/iterateAdjacentTiles\";\nimport { rarity } from \"../rarities\";\n\nconst tileConfigs = {\n  Coal: new TileConfig({\n    id: \"48217c09-300c-44b0-803e-19f51346227b\",\n    icon: Coal,\n    rarity: rarity.COMMON,\n    categories: [],\n    calculateValue: (context: TileValueContext) => {\n      let total = 1;\n\n      iterateAdjacentTiles(context, (tile: TileInstance) => {\n        if (tile.config.name === \"Coal\") {\n          total += 1;\n        }\n      });\n\n      return total;\n    },\n  }),\n  Dagger: new TileConfig({\n    id: \"2f2e6e35-686f-4033-9940-3f66a153c568\",\n    icon: Dagger1,\n    rarity: rarity.COMMON,\n    categories: [],\n    calculateValue: (context: TileValueContext) => {\n      return 1;\n    },\n  }),\n  Coin: new TileConfig({\n    id: \"49d24981-a7d1-4407-b121-ed3e45d427bd\",\n    icon: Coin,\n    rarity: rarity.COMMON,\n    categories: [],\n    calculateValue: (context: TileValueContext) => {\n      return 1;\n    },\n  }),\n};\n\nexport default tileConfigs;\n","import { TileInstance } from \"../../../types/TileInstance\";\n\nexport function hasCategory(tile: TileInstance, category: string) {\n  return tile.config.categories.includes(category);\n}\n","export function randomInt(min: number, max: number) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n","export const GAME_ID = \"9c0617fc-daf3-4f9c-943e-073f698ac0b8\";\n","import { GAME_ID } from \"./static\";\nimport { store } from \"./store\";\n\nexport function saveGameData() {\n  let localData = localStorage[`${GAME_ID}`];\n\n  if (localData) {\n    localData = JSON.parse(localData);\n  } else {\n    localData = {};\n  }\n\n  // Simple clone of just the data\n  const gameState = JSON.parse(JSON.stringify(store.state.gameData));\n\n  replaceTileConfigs(gameState.ownedTiles);\n  replaceTileConfigs(gameState.deckTiles);\n  replaceTileConfigs(gameState.gameTiles);\n\n  localData.gameState = gameState;\n  localData.saveDate = new Date();\n\n  localStorage[`${GAME_ID}`] = JSON.stringify(localData);\n}\n\nfunction replaceTileConfigs(tiles: any[]) {\n  for (const tile of tiles) {\n    tile.config = { id: tile.config.id };\n  }\n}\n","export const taxPeriods = [\n  {\n    totalDays: 0, // This will increment on starting a new game\n    taxAmount: 0,\n  },\n  {\n    totalDays: 5,\n    taxAmount: 25,\n  },\n  {\n    totalDays: 6,\n    taxAmount: 50,\n  },\n  {\n    totalDays: 7,\n    taxAmount: 100,\n  },\n  {\n    totalDays: 8,\n    taxAmount: 200,\n  },\n  {\n    totalDays: 9,\n    taxAmount: 400,\n  },\n  {\n    totalDays: 10,\n    taxAmount: 800,\n  },\n];\n","import { emptyTileConfig } from \"../config/tiles\";\nimport { maxRarity, rarity } from \"../config/tiles/rarities\";\nimport { TileInstance } from \"../types/TileInstance\";\nimport { createTile } from \"./createTile\";\nimport { randomInt } from \"./utils\";\nimport { store } from \"./store\";\nimport { saveGameData } from \"./saveGameData\";\nimport { taxPeriods } from \"../config/taxPeriods\";\nimport { v4 as uuid } from \"uuid\";\nimport { TileConfig } from \"../classes/TileConfig\";\n\nexport function findTile(tiles: TileInstance[], id: string) {\n  return tiles.find((tile) => {\n    return tile.config.id === id;\n  });\n}\n\nexport function addOwnedTile(tileConfig: TileConfig = emptyTileConfig) {\n  const { ownedTiles } = store.state.gameData;\n\n  if (findTile(ownedTiles, tileConfig.id)) {\n    console.log(`Already own tile ${tileConfig.name}`);\n    return;\n  }\n\n  console.log(`Adding owned tile ${tileConfig.name}`);\n\n  const tile = createTile(tileConfig);\n\n  ownedTiles.push(tile);\n}\n\nexport function addDeckTile(tileId?: string) {\n  if (!tileId) {\n    return;\n  }\n\n  const { deckTileIds } = store.state.gameData;\n\n  if (!deckTileIds.includes(tileId)) {\n    deckTileIds.push(tileId);\n  }\n}\nexport function addGameTile(newTile: TileInstance) {\n  const { gameTiles } = store.state.gameData;\n\n  const emptyTileIndex = gameTiles.findIndex((tile) => {\n    return tile.config.id === emptyTileConfig.id;\n  });\n\n  if (emptyTileIndex >= 0) {\n    gameTiles.splice(emptyTileIndex, 1, newTile);\n  } else {\n    gameTiles.push(newTile);\n  }\n}\n\nexport function buildDeck() {\n  const { gameData } = store.state;\n  const { deckTileIds, ownedTiles } = gameData;\n\n  gameData.deckTiles = deckTileIds.map((id) => {\n    return findTile(ownedTiles, id) || createTile(emptyTileConfig);\n  });\n}\n\nexport function ArrayRandomItem<T>(array: T[]) {\n  return array[randomInt(0, array.length - 1)];\n}\n\nexport function pickRandomTile(tiles: TileInstance[], maxRarity: number) {\n  const tilesAvailable = tiles.reduce((acc, tile) => {\n    if (tile.config.rarity <= maxRarity) {\n      acc.push(tile);\n    }\n\n    return acc;\n  }, [] as TileInstance[]);\n\n  return ArrayRandomItem<TileInstance>(tilesAvailable);\n}\n\nexport function setInitialGameTiles() {\n  const { gameData } = store.state;\n  const { deckTiles } = gameData;\n\n  const gameTiles: TileInstance[] = [];\n\n  for (let i = 0; i < 5; i++) {\n    const tile = pickRandomTile(deckTiles, rarity.COMMON);\n    gameTiles.push(createTile(tile.config));\n  }\n\n  gameData.gameTiles = gameTiles;\n\n  fillEmptyTiles();\n}\n\nexport function fillEmptyTiles() {\n  const { gameData } = store.state;\n  const { gameTiles, gridWidth, gridHeight } = gameData;\n\n  for (let i = 0; gameTiles.length < gridWidth * gridHeight; i++) {\n    gameTiles.push(createTile(emptyTileConfig));\n  }\n}\n\nexport function generateBoard() {\n  const { gameData } = store.state;\n  const { gameTiles, gridWidth, gridHeight } = gameData;\n  const boardTiles = [];\n  const availableGameTiles = [...gameTiles]; // New array\n\n  for (let i = 0; i < gridWidth * gridHeight; i++) {\n    // Get a random index\n    const availableIndex = Math.floor(\n      Math.random() * availableGameTiles.length\n    );\n    const gameTile = availableGameTiles[availableIndex];\n    const index = gameTiles.indexOf(gameTile);\n\n    // console.log(index);\n    boardTiles.push(index);\n\n    availableGameTiles.splice(availableIndex, 1);\n  }\n\n  return boardTiles;\n}\n\nexport function resetTiles() {\n  const { gridWidth, gridHeight, gameTiles, boardTiles } = store.state.gameData;\n\n  for (let i = 0; i < gridWidth * gridHeight; i++) {\n    const tile = gameTiles[boardTiles[i]];\n    tile.data.spinValue = 0;\n  }\n}\n\nexport function spin() {\n  const { gameData } = store.state;\n  const { gridWidth, gridHeight, deckTiles } = gameData;\n\n  gameData.boardTiles = generateBoard();\n\n  resetTiles();\n  processBoard();\n\n  store.state.spinning = true;\n  store.update();\n\n  let index = 0;\n  const interval = setInterval(() => {\n    const { boardTiles, gameTiles } = gameData;\n\n    if (index > 0 && index <= gridWidth * gridHeight) {\n      const lastTile = gameTiles[boardTiles[index - 1]];\n      lastTile.data.highlight = false;\n    }\n\n    if (index > gridWidth * gridHeight) {\n      // Spin finished\n\n      clearInterval(interval);\n\n      store.state.spinning = false;\n      store.state.gameData.totalCoins += store.state.gameData.boardValue;\n      store.state.tilesToPick = pickTiles(deckTiles);\n      store.update();\n\n      nextTaxPeriodDay();\n\n      saveGameData();\n\n      return;\n    }\n\n    if (index < gridWidth * gridHeight) {\n      const tile = gameTiles[boardTiles[index]];\n      tile.data.highlight = true;\n      tile.data.totalAppearances++;\n      tile.data.spinValue = calculateBoardTileValue(tile, index);\n    }\n\n    index++;\n\n    let boardValue = 0;\n\n    for (const boardTilesIndex of boardTiles) {\n      boardValue += gameTiles[boardTilesIndex].data.spinValue;\n    }\n    store.state.gameData.boardValue = boardValue;\n\n    store.update();\n  }, 100);\n}\n\nexport function processBoard() {\n  const { gameTiles } = store.state.gameData;\n\n  // Add to totalSpins\n  gameTiles.forEach((tile) => {\n    tile.data.totalSpins++;\n  });\n}\n\nexport function isAdjacent(\n  originIndex: number,\n  checkIndex: number,\n  width: number,\n  height: number\n) {\n  // Up / Down or out of bounds\n  if (checkIndex < 0 || checkIndex >= width * height) {\n    return false;\n  }\n\n  // Left / Right\n  if (originIndex + 1 === checkIndex || originIndex - 1 === checkIndex) {\n    if (Math.floor(checkIndex / width) !== Math.floor(originIndex / width)) {\n      return false;\n    }\n  }\n\n  // Down > Left / Right\n  if (\n    originIndex + width + 1 === checkIndex ||\n    originIndex + width - 1 === checkIndex\n  ) {\n    if (\n      Math.floor(checkIndex / width) !==\n      Math.floor((originIndex + width) / width)\n    ) {\n      return false;\n    }\n  }\n\n  // Up > Left / Right\n  if (\n    originIndex - width + 1 === checkIndex ||\n    originIndex - width - 1 === checkIndex\n  ) {\n    if (\n      Math.floor(checkIndex / width) !==\n      Math.floor((originIndex - width) / width)\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function getAdjacentIndexes(\n  startIndex: number,\n  width: number,\n  height: number\n): number[] {\n  const indexes: number[] = [];\n\n  indexes.push(startIndex + width);\n  indexes.push(startIndex - width);\n  indexes.push(startIndex + 1);\n  indexes.push(startIndex - 1);\n\n  indexes.push(startIndex + width - 1);\n  indexes.push(startIndex + width + 1);\n  indexes.push(startIndex - width - 1);\n  indexes.push(startIndex - width + 1);\n\n  for (let i = 7; i >= 0; i--) {\n    if (!isAdjacent(startIndex, indexes[i], width, height)) {\n      indexes.splice(i, 1);\n    }\n  }\n\n  return indexes;\n}\n\nfunction getTiles(tileIndexes: number[]) {\n  const { boardTiles, gameTiles } = store.state.gameData;\n\n  return tileIndexes.map((index) => {\n    return gameTiles[boardTiles[index]];\n  });\n}\n\nexport function calculateBoardTileValue(\n  tile: TileInstance,\n  boardIndex: number\n) {\n  const { gameData } = store.state;\n  const { gridWidth, gridHeight } = gameData;\n\n  const context = {\n    tile,\n    gameData,\n    getAdjacentIndexes: () => {\n      return getAdjacentIndexes(boardIndex, gridWidth, gridHeight);\n    },\n    getTiles,\n  };\n\n  return tile.config.calculateValue(context);\n}\n\nfunction getTileChances(tiles: TileInstance[]) {\n  const chances: number[] = [];\n  let chanceTotal = 0;\n\n  for (const tile of tiles) {\n    // The higher the rarity, the lower the chance\n    chanceTotal += maxRarity + 1 - tile.config.rarity;\n    chances.push(chanceTotal);\n  }\n\n  return { chances, chanceTotal };\n}\n\nfunction pickTiles(tiles: TileInstance[], count = 3) {\n  const availableTiles = [...tiles];\n  const pickedTiles = [];\n\n  for (let i = 0; i < count; i++) {\n    const { chances, chanceTotal } = getTileChances(availableTiles);\n\n    const rand = randomInt(0, chanceTotal);\n\n    const index = chances.findIndex((chance) => {\n      return chance >= rand;\n    });\n\n    const tile = availableTiles.splice(index, 1)[0];\n\n    if (tile) {\n      pickedTiles.push(createTile(tile.config));\n    }\n\n    // const index = randomInt(0, availableTiles.length - 1);\n    // const tile = availableTiles.splice(index, 1)[0];\n\n    // if (tile) {\n    //   pickedTiles.push(createTile(tile.config));\n    // }\n  }\n\n  return pickedTiles;\n}\n\nexport function nextTaxPeriodDay() {\n  const { gameData } = store.state;\n  const taxPeriod = taxPeriods[gameData.currentTaxPeriod];\n\n  gameData.currentTaxPeriodDay++;\n\n  if (gameData.currentTaxPeriodDay >= taxPeriod.totalDays) {\n    gameData.currentTaxPeriod++;\n    gameData.currentTaxPeriodDay = 1;\n\n    const newTotalCoins = gameData.totalCoins - taxPeriod.taxAmount;\n\n    if (newTotalCoins < 0) {\n      gameData.roundEnded = true;\n      gameData.savedCoins += gameData.totalCoins;\n      gameData.lastTotalCoins = gameData.totalCoins;\n    }\n\n    gameData.totalCoins = newTotalCoins;\n  }\n\n  store.update();\n}\n\nexport function addGameEvent({ message = \"\" }: any) {\n  const { gameData } = store.state;\n\n  gameData.events.push({\n    id: uuid(),\n    message,\n  });\n\n  console.log(`GAME EVENT: ${message}`);\n}\n\nexport function calculateDeckScore() {\n  const { gameData } = store.state;\n  let score = 0;\n\n  for (const tile of gameData.deckTiles) {\n    score += tile.config.rarity;\n  }\n\n  return score / gameData.deckTiles.length;\n}\n","import { emptyTileConfig } from \"..\";\nimport { createTile } from \"../../../lib/createTile\";\nimport { addGameTile } from \"../../../lib/game\";\nimport { TileInstance } from \"../../../types/TileInstance\";\nimport { TileValueContext } from \"../../../types/TileValueContext\";\n\nexport function removeTile(tile: TileInstance, context: TileValueContext) {\n  let removeValue;\n\n  if (tile.config.onRemove) {\n    removeValue = tile.config.onRemove(context);\n  }\n\n  const { gameTiles } = context.gameData;\n  const gameTilesIndex = gameTiles.indexOf(tile);\n\n  // Default the replacement tile to an empty one\n  let replaceTile = createTile(emptyTileConfig);\n\n  if (removeValue) {\n    let { tiles } = removeValue;\n\n    // Replace the tile with the appropriate value\n    if (tiles?.length) {\n      replaceTile = tiles[0];\n\n      // Add the remaining tiles\n      for (let i = 1; i < tiles.length; i++) {\n        addGameTile(tiles[i]);\n      }\n    }\n\n    // Apply the value\n    if (removeValue.value) {\n      replaceTile.data.spinValue = removeValue.value;\n    }\n  }\n\n  gameTiles[gameTilesIndex] = replaceTile;\n}\n","import { TileConfig } from \"../../../classes/TileConfig\";\nimport { TileValueContext } from \"../../../types/TileValueContext\";\nimport { rarity } from \"../rarities\";\nimport { iterateAdjacentTiles } from \"../lib/iterateAdjacentTiles\";\nimport { TileInstance } from \"../../../types/TileInstance\";\nimport { hasCategory } from \"../lib/hasCategory\";\nimport { removeTile } from \"../lib/removeTile\";\nimport { Chest1, Chest2, Chest3, Chest4, Coin, Key } from \"../icons/Icon\";\n\nfunction createChestConfig({ baseValue, removeValue }: any) {\n  return {\n    categories: [\"chest\"],\n    name: \"\",\n    description: () => {\n      return (\n        <>\n          Unlocked by the key, gives {removeValue} <Coin />\n        </>\n      );\n    },\n    calculateValue: (context: TileValueContext) => {\n      return baseValue;\n    },\n    onRemove: (context: TileValueContext) => {\n      return { value: removeValue };\n    },\n  };\n}\n\nconst tileConfigs = {\n  Key: new TileConfig({\n    id: \"2ef31449-bf1d-4cee-8e93-e0665fb9942a\",\n    name: \"\",\n    description: () => {\n      return (\n        <>\n          The key unlocks <Chest1 /> <Chest2 /> <Chest3 /> <Chest4 />,\n          destroying both in the process\n        </>\n      );\n    },\n    icon: Key,\n    rarity: rarity.COMMON,\n    categories: [\"key\"],\n    calculateValue: (context: TileValueContext) => {\n      let activated = false;\n\n      iterateAdjacentTiles(context, (tile: TileInstance) => {\n        if (hasCategory(tile, \"chest\")) {\n          // Remove the tile\n          removeTile(tile, context);\n          activated = true;\n        }\n      });\n\n      if (activated) {\n        // Remove self\n        removeTile(context.tile, context);\n      }\n\n      return 1;\n    },\n  }),\n  Small_Chest: new TileConfig({\n    id: \"834bf40d-0a3d-4e20-83a0-4e3aa233840c\",\n    icon: Chest1,\n    rarity: rarity.COMMON,\n    ...createChestConfig({ baseValue: 1, removeValue: 10 }),\n  }),\n  Medium_Chest: new TileConfig({\n    id: \"c87ea7e4-5479-4aa7-9033-0859d191390b\",\n    icon: Chest2,\n    rarity: rarity.UNCOMMON,\n    ...createChestConfig({ baseValue: 2, removeValue: 20 }),\n  }),\n  Large_Chest: new TileConfig({\n    id: \"8abbd4fc-1fee-4c14-b5c2-2a627de70dd1\",\n    icon: Chest3,\n    rarity: rarity.RARE,\n    ...createChestConfig({ baseValue: 3, removeValue: 30 }),\n  }),\n  Dark_Chest: new TileConfig({\n    id: \"3422f3a8-bd1a-4549-a9ff-d0ed0621d646\",\n    icon: Chest4,\n    rarity: rarity.LEGENDARY,\n    ...createChestConfig({ baseValue: 4, removeValue: 40 }),\n  }),\n};\n\nexport default tileConfigs;\n","import { TileConfig } from \"../../../classes/TileConfig\";\nimport { TileValueContext } from \"../../../types/TileValueContext\";\nimport { rarity } from \"../rarities\";\nimport { iterateAdjacentTiles } from \"../lib/iterateAdjacentTiles\";\nimport { TileInstance } from \"../../../types/TileInstance\";\nimport { hasCategory } from \"../lib/hasCategory\";\nimport { removeTile } from \"../lib/removeTile\";\nimport { Coal, Pickaxe, Rock } from \"../icons/Icon\";\nimport { createTile } from \"../../../lib/createTile\";\nimport { tileConfigsMap } from \"..\";\nimport { addGameEvent } from \"../../../lib/game\";\n\nconst tileConfigs = {\n  Pickaxe: new TileConfig({\n    id: \"102f6200-dd6b-434f-b486-67ccc425cc4d\",\n    name: \"\",\n    description: () => {\n      return <>Breaks rocks, has 3 uses</>;\n    },\n    icon: Pickaxe,\n    rarity: rarity.COMMON,\n    categories: [\"mining\"],\n    createMeta: () => {\n      return { uses: 3 };\n    },\n    topStat: (tile: TileInstance) => {\n      return tile.meta.uses;\n    },\n    calculateValue: (context: TileValueContext) => {\n      let broken = false;\n\n      iterateAdjacentTiles(context, (tile: TileInstance) => {\n        if (broken) {\n          return;\n        }\n\n        if (hasCategory(tile, \"rock\")) {\n          removeTile(tile, context);\n          console.log(context.tile.meta);\n          context.tile.meta.uses--;\n\n          if (context.tile.meta.uses === 0) {\n            broken = true;\n            addGameEvent({ message: \"A Pickaxe broke\" });\n          }\n        }\n      });\n\n      if (broken) {\n        // Remove self\n        removeTile(context.tile, context);\n      }\n\n      return 1;\n    },\n  }),\n  Rock: new TileConfig({\n    id: \"89c89fb8-b343-4767-ba9f-78b4586b4ceb\",\n    name: \"\",\n    description: () => {\n      return (\n        <>\n          Broken by <Pickaxe />, gives one of <Coal />\n        </>\n      );\n    },\n    icon: Rock,\n    rarity: rarity.COMMON,\n    categories: [\"rock\"],\n    calculateValue: (context: TileValueContext) => {\n      return 1;\n    },\n    onRemove: (context: TileValueContext) => {\n      const newTile = createTile(tileConfigsMap.Coal);\n\n      addGameEvent({\n        message: `A broken Rock yielded a ${newTile.config.name}`,\n      });\n\n      return { tiles: [newTile] };\n    },\n  }),\n};\n\nexport default tileConfigs;\n","export const categories = {\n  POTION: \"potion\",\n  SMALL_HEALTH_POTION: \"small-health-potion\",\n  MEDIUM_HEALTH_POTION: \"medium-health-potion\",\n  SMALL_MANA_POTION: \"small-mana-potion\",\n  MEDIUM_MANA_POTION: \"medium-mana-potion\",\n  SMALL_ELIXER: \"small-elixer\",\n  MEDIUM_ELIXER: \"medium-elixer\",\n};\n","import { TileInstance } from \"../../../types/TileInstance\";\nimport { TileValueContext } from \"../../../types/TileValueContext\";\nimport { hasCategory } from \"./hasCategory\";\nimport { iterateAdjacentTiles } from \"./iterateAdjacentTiles\";\n\nexport function findAdjacent(\n  context: TileValueContext,\n  category: string\n): TileInstance[] {\n  return iterateAdjacentTiles(context, (tile: TileInstance) => {\n    if (hasCategory(tile, category)) {\n      return tile;\n    }\n  }).reduce((acc, item) => {\n    if (item) {\n      acc.push(item);\n    }\n    return acc;\n  }, [] as TileInstance[]);\n}\n","import { calculateBoardTileValue } from \"../../../lib/game\";\nimport { TileInstance } from \"../../../types/TileInstance\";\nimport { TileValueContext } from \"../../../types/TileValueContext\";\n\nexport function replaceTile(\n  tile: TileInstance,\n  newTile: TileInstance,\n  context: TileValueContext\n) {\n  const { gameTiles, boardTiles } = context.gameData;\n  const gameTilesIndex = gameTiles.indexOf(tile);\n  const boardIndex = boardTiles.indexOf(gameTilesIndex);\n\n  gameTiles[gameTilesIndex] = newTile;\n\n  newTile.data.spinValue = calculateBoardTileValue(newTile, boardIndex);\n}\n","import { TileConfig } from \"../../../classes/TileConfig\";\nimport { createTile } from \"../../../lib/createTile\";\nimport { TileValueContext } from \"../../../types/TileValueContext\";\nimport { categories } from \"../categories\";\nimport {\n  HealthPotion1,\n  HealthPotion2,\n  Elixer1,\n  Elixer2,\n  ManaPotion1,\n  ManaPotion2,\n} from \"../icons/Icon\";\nimport { findAdjacent } from \"../lib/findAdjacent\";\nimport { removeTile } from \"../lib/removeTile\";\nimport { replaceTile } from \"../lib/replaceTile\";\nimport { rarity } from \"../rarities\";\n\nfunction findAndRemoveMatch(category: string, context: TileValueContext) {\n  const foundTiles = findAdjacent(context, category);\n\n  if (foundTiles.length) {\n    console.log(foundTiles);\n    removeTile(foundTiles[0], context);\n    return true;\n  }\n\n  return false;\n}\n\nfunction createElixer(category: string, context: TileValueContext) {\n  const foundTiles = findAdjacent(context, category);\n\n  if (foundTiles.length) {\n    removeTile(foundTiles[0], context);\n    replaceTile(context.tile, createTile(tileConfigs.Small_Elixer), context);\n    return true;\n  }\n\n  return false;\n}\n\nfunction createNextPotion(\n  category: string,\n  nextConfig: TileConfig,\n  context: TileValueContext\n) {\n  const foundTiles = findAdjacent(context, category);\n\n  if (foundTiles.length >= 2) {\n    removeTile(foundTiles[0], context);\n    removeTile(foundTiles[1], context);\n    replaceTile(context.tile, createTile(nextConfig), context);\n    return true;\n  }\n\n  return false;\n}\n\nconst tileConfigs = {\n  Small_Health_Potion: new TileConfig({\n    id: \"e77dc97d-8d44-45e4-bbad-deb79574092d\",\n    icon: HealthPotion1,\n    rarity: rarity.COMMON,\n    categories: [categories.SMALL_HEALTH_POTION],\n    calculateValue: (context: TileValueContext) => {\n      if (createElixer(categories.SMALL_MANA_POTION, context)) {\n        return 0;\n      }\n\n      if (\n        createNextPotion(\n          categories.SMALL_HEALTH_POTION,\n          tileConfigs.Medium_Health_Potion,\n          context\n        )\n      ) {\n        return 0;\n      }\n\n      return 1;\n    },\n  }),\n  Medium_Health_Potion: new TileConfig({\n    id: \"c6d67a75-f151-4503-b04d-2fb535c06c92\",\n    icon: HealthPotion2,\n    rarity: rarity.UNCOMMON,\n    categories: [categories.MEDIUM_HEALTH_POTION],\n    calculateValue: (context: TileValueContext) => {\n      return 2;\n    },\n  }),\n  Small_Mana_Potion: new TileConfig({\n    id: \"d587eba7-246e-46c7-bd55-2f32b0093cf8\",\n    icon: ManaPotion1,\n    rarity: rarity.COMMON,\n    categories: [categories.SMALL_MANA_POTION],\n    calculateValue: (context: TileValueContext) => {\n      if (createElixer(categories.SMALL_HEALTH_POTION, context)) {\n        return 0;\n      }\n\n      if (\n        createNextPotion(\n          categories.SMALL_MANA_POTION,\n          tileConfigs.Medium_Mana_Potion,\n          context\n        )\n      ) {\n        return 0;\n      }\n\n      return 1;\n    },\n  }),\n  Medium_Mana_Potion: new TileConfig({\n    id: \"6c067c0f-eefb-43ce-8f81-0aabd19cacc1\",\n    icon: ManaPotion2,\n    rarity: rarity.UNCOMMON,\n    categories: [categories.MEDIUM_MANA_POTION],\n    calculateValue: (context: TileValueContext) => {\n      return 2;\n    },\n  }),\n  Small_Elixer: new TileConfig({\n    id: \"93a94d4e-7a9d-4d1a-9f8a-3b1586530ca0\",\n    icon: Elixer1,\n    rarity: rarity.RARE,\n    categories: [categories.SMALL_ELIXER],\n    calculateValue: (context: TileValueContext) => {\n      if (\n        createNextPotion(\n          categories.SMALL_ELIXER,\n          tileConfigs.Medium_Elixer,\n          context\n        )\n      ) {\n        return 0;\n      }\n\n      return 5;\n    },\n  }),\n  Medium_Elixer: new TileConfig({\n    id: \"1fb94f1d-880e-41eb-9a29-f14700a22928\",\n    icon: Elixer2,\n    rarity: rarity.RARE,\n    categories: [categories.MEDIUM_ELIXER],\n    calculateValue: (context: TileValueContext) => {\n      return 10;\n    },\n  }),\n};\n\nexport default tileConfigs;\n","import { TileValueContext } from \"../../../types/TileValueContext\";\nimport { rarity } from \"../rarities\";\nimport { Empty } from \"../icons/Icon\";\nimport { TileConfig } from \"../../../classes/TileConfig\";\n\nconst tileConfigs = {\n  Empty: new TileConfig({\n    id: \"04f5df2c-22d6-4e31-8e81-c81f0ba1c4c1\",\n    name: \"\",\n    icon: Empty,\n    rarity: rarity.COMMON,\n    categories: [\"empty\"],\n    calculateValue: (context: TileValueContext) => {\n      return context.tile.data.spinValue || 0;\n    },\n  }),\n};\n\nexport default tileConfigs;\n","import { TileConfig } from \"../../classes/TileConfig\";\n\n// Sets\nimport set1 from \"./set1\";\nimport chests from \"./chests\";\nimport mining from \"./mining\";\nimport potions from \"./potions\";\nimport empty from \"./empty\";\nimport { TileInstance } from \"../../types/TileInstance\";\nimport { createTile } from \"../../lib/createTile\";\n\nexport const emptyTileConfig = empty.Empty;\n\nexport const tileConfigsMap = {\n  ...empty,\n  ...set1,\n  ...mining,\n  ...potions,\n  ...chests,\n};\n\nexport type TileConfigNames = keyof typeof tileConfigsMap;\n\n// Update the names on all tileConfigs\nfor (const tileName in tileConfigsMap) {\n  const tileConfig = (tileConfigsMap as any)[tileName];\n  tileConfig.name = tileName.replaceAll(\"_\", \" \");\n}\n\nconst tileConfigs: TileConfig[] = [...Object.values(tileConfigsMap)];\n\nexport default tileConfigs;\nexport const tilesById = new Map<string, TileConfig>();\nexport const tileInstances: TileInstance[] = [];\n\n// Setup the tiles by Id and name\ntileConfigs.forEach((config) => {\n  tilesById.set(config.id, config);\n  tileInstances.push(createTile(config));\n});\n\nexport function getTileConfigByName(name: TileConfigNames): TileConfig {\n  const tileConfig = tileConfigsMap[name];\n\n  if (!tileConfig) {\n    console.error(new Error(`Tile name \"${name}\" not found`));\n  }\n\n  return tileConfig;\n}\n","import { getTileConfigByName, TileConfigNames } from \"../config/tiles\";\nimport { GameData } from \"../types/GameData\";\nimport {\n  addDeckTile,\n  addOwnedTile,\n  buildDeck,\n  nextTaxPeriodDay,\n  setInitialGameTiles,\n} from \"./game\";\nimport { store } from \"./store\";\n\nfunction addTile(name: TileConfigNames) {\n  const tileConfig = getTileConfigByName(name);\n  addOwnedTile(tileConfig);\n  addDeckTile(tileConfig?.id);\n}\n\nexport function newGame() {\n  const gameData: GameData = {\n    boardTiles: [],\n    ownedTiles: [],\n    deckTileIds: [],\n    deckTiles: [],\n    gameTiles: [],\n    gridWidth: 3,\n    gridHeight: 3,\n    boardValue: 0,\n    totalCoins: 0,\n    savedCoins: 0,\n    lastTotalCoins: 0,\n    currentTaxPeriod: 0,\n    currentTaxPeriodDay: 0,\n    roundEnded: false,\n    events: [],\n  };\n\n  store.state.gameData = gameData;\n  store.state.tilesToPick = [];\n\n  addTile(\"Coal\");\n  addTile(\"Dagger\");\n  addTile(\"Pickaxe\");\n  addTile(\"Rock\");\n  // addTile(\"Key\");\n  // addTile(\"Small Chest\");\n  // addTile(\"Medium Chest\");\n\n  buildDeck();\n  setInitialGameTiles();\n  nextTaxPeriodDay();\n}\n","import { GameData } from \"../types/GameData\";\nimport { TileInstance } from \"../types/TileInstance\";\nimport { GAME_ID } from \"./static\";\nimport { store } from \"./store\";\nimport tileConfigs, { emptyTileConfig } from \"../config/tiles\";\n\nexport function loadGameData() {\n  let localData = localStorage[`${GAME_ID}`];\n\n  if (localData) {\n    localData = JSON.parse(localData);\n  } else {\n    localData = {};\n  }\n\n  if (localData?.gameState) {\n    // Must update configs with references to the actual objects\n    const gameState: GameData = localData.gameState;\n\n    updateTileConfigs(gameState.ownedTiles);\n    updateTileConfigs(gameState.deckTiles);\n    updateTileConfigs(gameState.gameTiles);\n\n    store.state.gameData = localData.gameState;\n  }\n}\n\nfunction updateTileConfigs(tiles: TileInstance[]) {\n  for (const tile of tiles) {\n    tile.config =\n      tileConfigs.find((tileConfig) => {\n        return tileConfig.id === tile.config.id;\n      }) || emptyTileConfig;\n  }\n}\n","import { store } from \"../lib/store\";\nimport { TileInstance } from \"../types/TileInstance\";\n\ninterface Props {\n  tile: TileInstance;\n  showValue?: boolean;\n  onClick?: (tile: TileInstance) => void;\n}\n\nexport function Tile({ tile, showValue, onClick }: Props) {\n  const className = [\"tile\"];\n\n  if (tile.data.highlight) {\n    className.push(\"highlight\");\n  }\n\n  function clickedTile() {\n    store.state.selectedTile = tile;\n    store.update();\n\n    if (onClick) {\n      onClick(tile);\n    }\n  }\n\n  return (\n    <div className={className.join(\" \")} onClick={clickedTile}>\n      {!!tile.config.topStat && showValue && (\n        <div className=\"top-stat\">{tile.config.topStat(tile)}</div>\n      )}\n      {!!tile.data.spinValue && showValue && (\n        <div className=\"value\">{tile.data.spinValue}</div>\n      )}\n      <tile.config.icon />\n    </div>\n  );\n}\n","import { TileInstance } from \"../types/TileInstance\";\nimport { Tile } from \"./Tile\";\n\ninterface Props {\n  tiles: TileInstance[];\n  onClickTile?: (tile: TileInstance) => void;\n}\n\nexport function Inventory({ tiles, onClickTile }: Props) {\n  return (\n    <div className=\"inventory\">\n      {tiles.map((tile) => (\n        <Tile key={tile.id} tile={tile} onClick={onClickTile} />\n      ))}\n    </div>\n  );\n}\n","import { nextTaxPeriodDay, setInitialGameTiles } from \"./game\";\nimport { store } from \"./store\";\n\nexport function newRound() {\n  const { gameData } = store.state;\n\n  gameData.currentTaxPeriod = 0;\n  gameData.currentTaxPeriodDay = 0;\n  gameData.roundEnded = false;\n  gameData.boardTiles = [];\n  gameData.totalCoins = 0;\n  gameData.events = [];\n\n  setInitialGameTiles();\n  nextTaxPeriodDay();\n\n  store.state.tilesToPick = [];\n\n  store.update();\n}\n","import { Inventory } from \"../components/Inventory\";\nimport { emptyTileConfig, tileInstances } from \"../config/tiles\";\nimport { rarity } from \"../config/tiles/rarities\";\nimport { createTile } from \"../lib/createTile\";\nimport { addOwnedTile, calculateDeckScore, findTile } from \"../lib/game\";\nimport { newRound } from \"../lib/newRound\";\nimport { store } from \"../lib/store\";\nimport { randomInt } from \"../lib/utils\";\nimport { TileInstance } from \"../types/TileInstance\";\n\nexport function RoundEnd() {\n  const deckScore = calculateDeckScore();\n\n  const { gameData } = store.state;\n\n  function tileRarityCost(rarityValue: number, rarityCount: number) {\n    return Math.pow(rarityValue + 1, 2) * 100 * (rarityCount + 1);\n  }\n\n  function getRemainingTiles() {\n    const availableTilesByRarity: TileInstance[][] = Object.keys(\n      rarity\n    ).map(() => []);\n    const allTilesByRarity: TileInstance[][] = Object.keys(\n      rarity\n    ).map(() => []);\n    const ownedRarityCounts: number[] = Object.keys(rarity).map(() => 0);\n\n    tileInstances.forEach((tile) => {\n      allTilesByRarity[tile.config.rarity].push(tile);\n\n      if (tile.config === emptyTileConfig) {\n        // Skip the empty tile\n        return;\n      }\n\n      if (!findTile(gameData.ownedTiles, tile.config.id)) {\n        availableTilesByRarity[tile.config.rarity].push(tile);\n      } else {\n        ownedRarityCounts[tile.config.rarity]++;\n      }\n    });\n\n    return {\n      availableTilesByRarity,\n      allTilesByRarity,\n      ownedRarityCounts,\n    };\n  }\n\n  function buyTileRarity(rarity: number) {\n    const { availableTilesByRarity, ownedRarityCounts } = getRemainingTiles();\n\n    const rarityTiles = availableTilesByRarity[rarity];\n\n    const index = randomInt(0, rarityTiles.length - 1);\n\n    gameData.savedCoins -= tileRarityCost(rarity, ownedRarityCounts[rarity]);\n\n    addOwnedTile(rarityTiles[index].config);\n\n    store.update();\n  }\n\n  const {\n    availableTilesByRarity,\n    allTilesByRarity,\n    ownedRarityCounts,\n  } = getRemainingTiles();\n\n  return (\n    <div>\n      <h1>The round is over</h1>\n      <h2>\n        Saved Coins: {gameData.savedCoins} ({gameData.lastTotalCoins} earned\n        last round)\n      </h2>\n      <div>\n        <div>\n          This is your chance to get a new tile. Getting a new tile will\n          increase the cost of the next tile of the same rarity\n        </div>\n        <div className=\"buy-new-card\">\n          {Object.keys(rarity).map((rarityName, index) => {\n            const rarityValue = (rarity as any)[rarityName];\n            const rarityCount = ownedRarityCounts[index];\n            const cost = tileRarityCost(rarityValue, rarityCount);\n            const availableTiles = availableTilesByRarity[index].length;\n            const className = [\"rarity\"];\n            let enabled = true;\n\n            if (cost > gameData.savedCoins || availableTiles === 0) {\n              className.push(\"disabled\");\n              enabled = false;\n            }\n\n            return (\n              <div key={rarityValue} className={className.join(\" \")}>\n                <div className=\"name\">{rarityName}</div>\n                <div className=\"cost\">{cost}</div>\n                <div className=\"remaining-tiles\">\n                  {availableTilesByRarity[index].length} of{\" \"}\n                  {allTilesByRarity[index].length} tiles available\n                </div>\n                {enabled && (\n                  <button onClick={() => buyTileRarity(index)}>Buy</button>\n                )}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n      <div>\n        <div>Take this time to reorganize your deck</div>\n        <div>\n          <h1>Deck</h1>\n          <div style={{ background: deckScore > 1 ? \"red\" : \"none\" }}>\n            Deck Score: {deckScore.toFixed(2)}\n          </div>\n          <Inventory\n            tiles={gameData.deckTiles}\n            onClickTile={(tile) => {\n              const index = gameData.deckTiles.indexOf(tile);\n\n              if (index >= 0) {\n                gameData.deckTiles.splice(index, 1);\n              }\n            }}\n          />\n        </div>\n      </div>\n      <div>\n        <div>\n          <h1>Owned Inventory</h1>\n          <Inventory\n            tiles={gameData.ownedTiles}\n            onClickTile={(tile) => {\n              const hasTile = gameData.deckTiles.find((otherTile) => {\n                return otherTile.config.id === tile.config.id;\n              });\n\n              if (!hasTile) {\n                gameData.deckTiles.push(tile);\n              }\n            }}\n          />\n        </div>\n      </div>\n      <div>\n        <h1>All Tiles</h1>\n        <Inventory\n          tiles={tileInstances}\n          onClickTile={(tile) => {\n            const hasTile = gameData.ownedTiles.find((otherTile) => {\n              return otherTile.config.id === tile.config.id;\n            });\n\n            if (!hasTile) {\n              gameData.ownedTiles.push(createTile(tile.config));\n            }\n          }}\n        />\n      </div>\n\n      <button onClick={newRound}>Next round</button>\n    </div>\n  );\n}\n","import { createTile } from \"../lib/createTile\";\nimport { emptyTileConfig } from \"../config/tiles\";\nimport { TileInstance } from \"../types/TileInstance\";\nimport { Tile } from \"./Tile\";\n\ninterface Props {\n  boardTiles: number[];\n  gameTiles: TileInstance[];\n  width: number;\n  height: number;\n}\n\nexport function Board({ boardTiles, gameTiles, width, height }: Props) {\n  const style = {\n    fontSize: \"1.5em\",\n    gridTemplateColumns: `repeat(${width}, 5em)`,\n    gridTemplateRows: `repeat(${height}, 5em)`,\n  };\n\n  if (boardTiles.length === 0) {\n    const emptyTileInstance = createTile(emptyTileConfig);\n\n    return (\n      <div className=\"board\" style={style}>\n        {\" \"\n          .repeat(width * height)\n          .split(\"\")\n          .map((_, index) => {\n            return <Tile key={index} tile={emptyTileInstance} />;\n          })}\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"board\" style={style}>\n      {boardTiles.map((deckIndex, index) => {\n        const tile = gameTiles[deckIndex];\n        return <Tile key={tile.id} tile={tile} showValue onClick={() => {}} />;\n      })}\n    </div>\n  );\n}\n","import { TileInstance } from \"../types/TileInstance\";\n\ninterface Props {\n  tile?: TileInstance;\n  onClick?: any;\n}\n\nexport function TileDetails({ tile, onClick }: Props) {\n  if (!tile) {\n    return null;\n  }\n\n  const { config } = tile;\n\n  return (\n    <div className=\"tile-details\" onClick={onClick}>\n      <div className=\"name\">{config.name}</div>\n      <tile.config.icon />\n      <div className=\"description\">\n        {config.description && config.description()}\n      </div>\n    </div>\n  );\n}\n","import { addGameTile } from \"../lib/game\";\nimport { store } from \"../lib/store\";\nimport { TileInstance } from \"../types/TileInstance\";\nimport { TileDetails } from \"./TileDetails\";\n\nexport function PickNewTile() {\n  const { tilesToPick } = store.state;\n\n  function pickTile(tile?: TileInstance) {\n    if (tile) {\n      addGameTile(tile);\n    }\n\n    store.state.tilesToPick = [];\n    store.state.gameData.boardTiles = [];\n    store.update();\n  }\n\n  return (\n    <div className=\"pick-a-tile\">\n      {tilesToPick.map((tile) => (\n        <TileDetails\n          key={tile.id}\n          tile={tile}\n          onClick={() => {\n            pickTile(tile);\n          }}\n        />\n      ))}\n      <button onClick={() => pickTile()}>Skip</button>\n    </div>\n  );\n}\n","import { fillEmptyTiles } from \"../lib/game\";\nimport { store } from \"../lib/store\";\n\nconst upgrades = [\n  {\n    id: \"bbe17879-f3ee-47fc-9e76-2fa8cc0ebc0d\",\n    name: \"Board Width\",\n    cost: () => {\n      return 0;\n    },\n    buy: () => {\n      const { gameData } = store.state;\n      gameData.gridWidth += 1;\n      fillEmptyTiles();\n      store.update();\n    },\n    isComplete: () => {\n      return false;\n    },\n  },\n  {\n    id: \"1e0ab330-8ec9-4e41-933d-75251ffa5ee5\",\n    name: \"Board Height\",\n    cost: () => {\n      return 0;\n    },\n    buy: () => {\n      const { gameData } = store.state;\n      gameData.gridHeight += 1;\n      fillEmptyTiles();\n      store.update();\n    },\n    isComplete: () => {\n      return false;\n    },\n  },\n  {\n    id: \"0245c559-dd55-4f93-a626-53cc06b17d42\",\n    name: \"XYZ\",\n    cost: () => {\n      return 0;\n    },\n    buy: () => {},\n    isComplete: () => {\n      return false;\n    },\n  },\n];\n\nexport function Upgrades() {\n  return (\n    <div className=\"upgrades\">\n      {upgrades.map((upgrade) => {\n        return (\n          <div key={upgrade.id}>\n            <div>{upgrade.name}</div>\n            <div>\n              <button onClick={upgrade.buy}>Buy</button>\n            </div>\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n","import { GameEvent } from \"../types/GameData\";\n\ninterface Props {\n  events: GameEvent[];\n}\n\nexport function GameEvents({ events }: Props) {\n  return (\n    <div className=\"game-events\">\n      {events.map((event) => (\n        <div key={event.id} className=\"event\">\n          <div className=\"message\">{event.message}</div>\n        </div>\n      ))}\n    </div>\n  );\n}\n","import { Board } from \"../components/Board\";\nimport { Inventory } from \"../components/Inventory\";\nimport { store } from \"../lib/store\";\nimport { newGame } from \"../lib/newGame\";\nimport { calculateDeckScore, spin } from \"../lib/game\";\nimport { PickNewTile } from \"../components/PickNewTile\";\nimport { TileDetails } from \"../components/TileDetails\";\nimport { Upgrades } from \"../components/Upgrades\";\nimport { loadGameData } from \"../lib/loadGameData\";\nimport { taxPeriods } from \"../config/taxPeriods\";\nimport { Coin } from \"../config/tiles/icons/Icon\";\nimport { GameEvents } from \"../components/GameEvents\";\nimport { saveGameData } from \"../lib/saveGameData\";\nimport { tileInstances } from \"../config/tiles\";\nimport { createTile } from \"../lib/createTile\";\nimport packageJson from \"../../package.json\";\n\nloadGameData();\n\nfunction Header() {\n  const { gameData } = store.state;\n  const taxPeriod = taxPeriods[gameData.currentTaxPeriod];\n\n  return (\n    <>\n      <div style={{ fontSize: \"3em\" }}>\n        {gameData.totalCoins}\n        <span className=\"icon-em\">\n          <Coin />\n        </span>{\" \"}\n        / {taxPeriod.taxAmount}\n        <span className=\"icon-em\">\n          <Coin />\n        </span>{\" \"}\n        taxes due in {taxPeriod.totalDays - gameData.currentTaxPeriodDay} Days\n      </div>\n      <div>Saved Coins: {gameData.savedCoins}</div>\n    </>\n  );\n}\n\nexport function MainGame() {\n  const { gameData, tilesToPick } = store.state;\n\n  let buttons = null;\n  if (!store.state.spinning && !tilesToPick.length) {\n    buttons = (\n      <>\n        <button onClick={spin}>Spin</button>\n      </>\n    );\n  }\n\n  const deckScore = calculateDeckScore();\n\n  return (\n    <div className=\"app\">\n      <div>Version: {packageJson.version}</div>\n      <Header />\n      {!!tilesToPick.length && (\n        <div>\n          <h1>Pick New Tile</h1>\n          <PickNewTile />\n        </div>\n      )}\n      <div style={{ opacity: tilesToPick.length ? 0.5 : 1 }}>\n        <div style={{ display: \"flex\", flexDirection: \"row\" }}>\n          <div>\n            <h1>Board</h1>\n            <Board\n              boardTiles={gameData.boardTiles}\n              gameTiles={gameData.gameTiles}\n              width={gameData.gridWidth}\n              height={gameData.gridHeight}\n            />\n            {buttons}\n            <div style={{ fontSize: \"2em\" }}>\n              Board value:{\" \"}\n              <b>{(!!gameData.boardValue && gameData.boardValue) || 0}</b>\n            </div>\n          </div>\n          <div style={{ width: \"1em\" }}></div>\n          <div>\n            <h1>Selected Tile</h1>\n            <TileDetails tile={store.state.selectedTile} />\n          </div>\n          <div style={{ width: \"1em\" }}></div>\n          <div>\n            <h1>Events</h1>\n            <GameEvents events={gameData.events} />\n          </div>\n        </div>\n        <div>\n          <h1>Game Tiles</h1>\n          <Inventory tiles={gameData.gameTiles} />\n        </div>\n        <div>\n          <h1>Deck</h1>\n          <div style={{ background: deckScore > 1 ? \"red\" : \"none\" }}>\n            Deck Score: {deckScore.toFixed(2)}\n          </div>\n          <Inventory tiles={gameData.deckTiles} />\n        </div>\n        <div>\n          <h1>Owned Inventory</h1>\n          <Inventory tiles={gameData.ownedTiles} />\n        </div>\n        <div>\n          <h1>All Tiles</h1>\n          <Inventory\n            tiles={tileInstances}\n            onClickTile={(tile) => {\n              const hasTile = gameData.ownedTiles.find((otherTile) => {\n                return otherTile.config.id === tile.config.id;\n              });\n\n              if (!hasTile) {\n                gameData.ownedTiles.push(createTile(tile.config));\n              }\n            }}\n          />\n        </div>\n        <div>\n          <h1>Upgrades</h1>\n          <Upgrades />\n        </div>\n        <button\n          onClick={() => {\n            newGame();\n            store.update();\n          }}\n        >\n          Reset all game data\n        </button>\n        <button\n          onClick={() => {\n            saveGameData();\n          }}\n        >\n          Save game data\n        </button>\n      </div>\n      <div>\n        <button\n          onClick={() => {\n            gameData.roundEnded = true;\n            store.update();\n          }}\n        >\n          End Round\n        </button>\n      </div>\n    </div>\n  );\n}\n","import { store } from \"./lib/store\";\nimport { useEffect, useState } from \"react\";\nimport { newGame } from \"./lib/newGame\";\nimport { loadGameData } from \"./lib/loadGameData\";\nimport { MainGame, RoundEnd } from \"./views\";\n\nloadGameData();\n\nfunction App() {\n  const update = useState(0)[1];\n\n  // Did mount / unmount\n  useEffect(() => {\n    store._update = update;\n  }, [update]);\n\n  if (!store.state.gameData) {\n    newGame();\n  }\n\n  const { gameData } = store.state;\n\n  if (gameData.roundEnded) {\n    return <RoundEnd />;\n  }\n\n  return <MainGame />;\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./styles/main.scss\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}